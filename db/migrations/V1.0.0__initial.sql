-- Database generated with pgModeler (PostgreSQL Database Modeler).
-- pgModeler version: 0.9.4-beta1
-- PostgreSQL version: 12.0
-- Project Site: pgmodeler.io
-- Model Author: ---
-- -- object: jkr_admin | type: ROLE --
-- -- DROP ROLE IF EXISTS jkr_admin;
-- CREATE ROLE jkr_admin WITH 
-- 	LOGIN
-- 	ENCRYPTED PASSWORD 'jkr_admin';
-- -- ddl-end --
-- 
-- -- object: public | type: ROLE --
-- -- DROP ROLE IF EXISTS public;
-- CREATE ROLE public WITH ;
-- -- ddl-end --
-- 

-- Database creation must be performed outside a multi lined SQL file. 
-- These commands were put in this file only as a convenience.
-- 
-- -- object: ymparisto_db | type: DATABASE --
-- -- DROP DATABASE IF EXISTS ymparisto_db;
-- CREATE DATABASE ymparisto_db
-- 	ENCODING = 'UTF8'
-- 	LC_COLLATE = 'en_US.utf8'
-- 	LC_CTYPE = 'en_US.utf8'
-- 	TABLESPACE = pg_default
-- 	OWNER = postgres;
-- -- ddl-end --
-- 

SET check_function_bodies = false;
-- ddl-end --

-- -- object: jkr | type: SCHEMA --
-- -- DROP SCHEMA IF EXISTS jkr CASCADE;
-- CREATE SCHEMA jkr;
-- -- ddl-end --
-- ALTER SCHEMA jkr OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- object: jkr_koodistot | type: SCHEMA --
-- DROP SCHEMA IF EXISTS jkr_koodistot CASCADE;
CREATE SCHEMA jkr_koodistot;
-- ddl-end --
ALTER SCHEMA jkr_koodistot OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr_osoite | type: SCHEMA --
-- DROP SCHEMA IF EXISTS jkr_osoite CASCADE;
CREATE SCHEMA jkr_osoite;
-- ddl-end --
ALTER SCHEMA jkr_osoite OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr_facta | type: SCHEMA --
-- DROP SCHEMA IF EXISTS jkr_facta CASCADE;
CREATE SCHEMA jkr_facta;
-- ddl-end --
ALTER SCHEMA jkr_facta OWNER TO jkr_admin;
-- ddl-end --

SET search_path TO pg_catalog,public,jkr,jkr_koodistot,jkr_osoite,jkr_facta;
-- ddl-end --

-- -- object: public.geometry | type: TYPE --
-- -- DROP TYPE IF EXISTS public.geometry CASCADE;
-- CREATE TYPE public.geometry;
-- -- ddl-end --
-- 
-- -- object: public.geometry_cp | type: TYPE --
-- -- DROP TYPE IF EXISTS public.geometry_cp CASCADE;
-- CREATE TYPE public.geometry_cp;
-- -- ddl-end --
-- 
-- -- object: postgis | type: EXTENSION --
-- -- DROP EXTENSION IF EXISTS postgis CASCADE;
-- CREATE EXTENSION postgis
-- WITH SCHEMA public;
-- -- ddl-end --
-- 
-- object: jkr.kohde | type: TABLE --
-- DROP TABLE IF EXISTS jkr.kohde CASCADE;
CREATE TABLE jkr.kohde (
	id serial NOT NULL,
	nimi text,
	geom geometry(POLYGON, 3878),
	alkupvm date,
	loppupvm date,
	voimassaolo daterange GENERATED ALWAYS AS (daterange(coalesce(alkupvm, '-infinity'), coalesce(loppupvm, 'infinity'), '[]')) STORED,
	kohdetyyppi_id integer NOT NULL,
	CONSTRAINT kohde_pk PRIMARY KEY (id)
);
-- ddl-end --
COMMENT ON TABLE jkr.kohde IS E'Kohde koostuu yhden omistajan hallinnoimista lähekkäisistä rakennuksista.\nRakennukset voivat sijaita myös eri kiinteistöillä.\nYhdellä kiinteistöllä voi olla useita kohteita.';
-- ddl-end --
COMMENT ON COLUMN jkr.kohde.geom IS E'Pseudo geom for kohde. Geometry is autogenerated from convex hull of included buildings.';
-- ddl-end --
ALTER TABLE jkr.kohde OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr.velvoitemalli | type: TABLE --
-- DROP TABLE IF EXISTS jkr.velvoitemalli CASCADE;
CREATE TABLE jkr.velvoitemalli (
	id serial NOT NULL,
	selite text,
	saanto text,
	tayttymissaanto text,
	jatetyyppi_id integer NOT NULL,
	CONSTRAINT velvoitemalli_pk PRIMARY KEY (id)
);
-- ddl-end --
COMMENT ON COLUMN jkr.velvoitemalli.saanto IS E'Velvoitteeseen liittymisen sääntö SQL-kyselynä, joka palauttaa velvoitetta koskevat kohteet';
-- ddl-end --
COMMENT ON COLUMN jkr.velvoitemalli.tayttymissaanto IS E'SQL-kysely, joka palauttaa kohde_velvoitteelle true/false onko velvoite kunnossa';
-- ddl-end --
ALTER TABLE jkr.velvoitemalli OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr_koodistot.jatetyyppi | type: TABLE --
-- DROP TABLE IF EXISTS jkr_koodistot.jatetyyppi CASCADE;
CREATE TABLE jkr_koodistot.jatetyyppi (
	id serial NOT NULL,
	selite text NOT NULL,
	ewc char(6),
	CONSTRAINT jatetyyppi_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr_koodistot.jatetyyppi OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr.velvoite | type: TABLE --
-- DROP TABLE IF EXISTS jkr.velvoite CASCADE;
CREATE TABLE jkr.velvoite (
	id serial NOT NULL,
	alkupvm date,
	loppupvm date,
	kohde_id integer NOT NULL,
	velvoitemalli_id integer NOT NULL,
	CONSTRAINT velvoite_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr.velvoite OWNER TO jkr_admin;
-- ddl-end --

-- object: kohde_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.velvoite DROP CONSTRAINT IF EXISTS kohde_fk CASCADE;
ALTER TABLE jkr.velvoite ADD CONSTRAINT kohde_fk FOREIGN KEY (kohde_id)
REFERENCES jkr.kohde (id) MATCH FULL
ON DELETE RESTRICT ON UPDATE CASCADE;
-- ddl-end --

-- object: velvoitemalli_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.velvoite DROP CONSTRAINT IF EXISTS velvoitemalli_fk CASCADE;
ALTER TABLE jkr.velvoite ADD CONSTRAINT velvoitemalli_fk FOREIGN KEY (velvoitemalli_id)
REFERENCES jkr.velvoitemalli (id) MATCH FULL
ON DELETE RESTRICT ON UPDATE CASCADE;
-- ddl-end --

-- object: jkr.kiinteisto | type: TABLE --
-- DROP TABLE IF EXISTS jkr.kiinteisto CASCADE;
CREATE TABLE jkr.kiinteisto (
	id serial NOT NULL,
	kiinteistotunnus text,
	geom geometry(MULTIPOLYGON, 3878),
	omistaja_osapuoli_id integer,
	CONSTRAINT kiinteisto_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr.kiinteisto OWNER TO jkr_admin;
-- ddl-end --

-- object: kiinteistotunnus_idx | type: INDEX --
-- DROP INDEX IF EXISTS jkr.kiinteistotunnus_idx CASCADE;
CREATE UNIQUE INDEX kiinteistotunnus_idx ON jkr.kiinteisto
USING btree
(
	kiinteistotunnus
);
-- ddl-end --

-- object: jkr.osapuoli | type: TABLE --
-- DROP TABLE IF EXISTS jkr.osapuoli CASCADE;
CREATE TABLE jkr.osapuoli (
	id serial NOT NULL,
	sukunimi text,
	etunimi text,
	katuosoite text,
	postitoimipaikka text,
	erikoisosoite text,
	ytunnus text,
	facta_id bigint,
	posti_numero char(5),
	osapuolenlaji_koodi char(2),
	CONSTRAINT osapuoli_pk PRIMARY KEY (id)
);
-- ddl-end --
COMMENT ON COLUMN jkr.osapuoli.erikoisosoite IS E'Ulkomaanosoitteet';
-- ddl-end --
ALTER TABLE jkr.osapuoli OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr.rakennus | type: TABLE --
-- DROP TABLE IF EXISTS jkr.rakennus CASCADE;
CREATE TABLE jkr.rakennus (
	id serial NOT NULL,
	prt char(10),
	huoneistomaara smallint,
	kiinteistotunnus text,
	onko_viemari bool,
	geom geometry(POINT, 3878),
	rakennuksenkayttotarkoitus_koodi char(3),
	rakennuksenolotila_koodi char(2),
	CONSTRAINT rakennus_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr.rakennus OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr.kuljetus | type: TABLE --
-- DROP TABLE IF EXISTS jkr.kuljetus CASCADE;
CREATE TABLE jkr.kuljetus (
	id serial NOT NULL,
	alkupvm date NOT NULL,
	loppupvm date NOT NULL,
	tyhjennyskerrat smallint,
	massa integer,
	tilavuus smallint,
	aikavali daterange GENERATED ALWAYS AS (daterange(coalesce(alkupvm, '-infinity'), coalesce(loppupvm, 'infinity'), '[]')) STORED,
	kohde_id integer NOT NULL,
	jatetyyppi_id integer NOT NULL,
	urakoitsija_osapuoli_id integer NOT NULL,
	CONSTRAINT kuljetus_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr.kuljetus OWNER TO jkr_admin;
-- ddl-end --

-- object: kiinteisto_geom_idx | type: INDEX --
-- DROP INDEX IF EXISTS jkr.kiinteisto_geom_idx CASCADE;
CREATE INDEX kiinteisto_geom_idx ON jkr.kiinteisto
USING gist
(
	geom
);
-- ddl-end --

-- object: omistaja_osapuoli_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.kiinteisto DROP CONSTRAINT IF EXISTS omistaja_osapuoli_fk CASCADE;
ALTER TABLE jkr.kiinteisto ADD CONSTRAINT omistaja_osapuoli_fk FOREIGN KEY (omistaja_osapuoli_id)
REFERENCES jkr.osapuoli (id) MATCH FULL
ON DELETE SET NULL ON UPDATE CASCADE;
-- ddl-end --

-- object: jkr.keraysvaline | type: TABLE --
-- DROP TABLE IF EXISTS jkr.keraysvaline CASCADE;
CREATE TABLE jkr.keraysvaline (
	id serial NOT NULL,
	pvm date NOT NULL,
	koko smallint NOT NULL,
	maara smallint NOT NULL,
	sopimus_id integer NOT NULL,
	CONSTRAINT keraysvaline_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr.keraysvaline OWNER TO jkr_admin;
-- ddl-end --

-- object: rakennus_geom_idx | type: INDEX --
-- DROP INDEX IF EXISTS jkr.rakennus_geom_idx CASCADE;
CREATE INDEX rakennus_geom_idx ON jkr.rakennus
USING gist
(
	geom
);
-- ddl-end --

-- -- object: jkr.flyway_schema_history | type: TABLE --
-- -- DROP TABLE IF EXISTS jkr.flyway_schema_history CASCADE;
-- CREATE TABLE jkr.flyway_schema_history (
-- 	installed_rank integer NOT NULL,
-- 	version character varying(50),
-- 	description character varying(200) NOT NULL,
-- 	type character varying(20) NOT NULL,
-- 	script character varying(1000) NOT NULL,
-- 	checksum integer,
-- 	installed_by character varying(100) NOT NULL,
-- 	installed_on timestamp NOT NULL DEFAULT now(),
-- 	execution_time integer NOT NULL,
-- 	success boolean NOT NULL,
-- 	CONSTRAINT flyway_schema_history_pk PRIMARY KEY (installed_rank)
-- );
-- -- ddl-end --
-- ALTER TABLE jkr.flyway_schema_history OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: flyway_schema_history_s_idx | type: INDEX --
-- -- DROP INDEX IF EXISTS jkr.flyway_schema_history_s_idx CASCADE;
-- CREATE INDEX flyway_schema_history_s_idx ON jkr.flyway_schema_history
-- USING btree
-- (
-- 	success
-- )
-- WITH (FILLFACTOR = 90);
-- -- ddl-end --
-- 
-- -- object: jkr.qgis_projects | type: TABLE --
-- -- DROP TABLE IF EXISTS jkr.qgis_projects CASCADE;
-- CREATE TABLE jkr.qgis_projects (
-- 	name text NOT NULL,
-- 	metadata jsonb,
-- 	content bytea,
-- 	CONSTRAINT qgis_projects_pkey PRIMARY KEY (name)
-- );
-- -- ddl-end --
-- ALTER TABLE jkr.qgis_projects OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- object: jkr.taajama | type: TABLE --
-- DROP TABLE IF EXISTS jkr.taajama CASCADE;
CREATE TABLE jkr.taajama (
	id serial NOT NULL,
	geom geometry(MULTIPOLYGON, 3878),
	CONSTRAINT taajama_pk PRIMARY KEY (id)
);
-- ddl-end --
COMMENT ON TABLE jkr.taajama IS E'biojätevelvoite koskee kiinteistöjä, jotka ovat 10000 taajamarajan sisällä';
-- ddl-end --
ALTER TABLE jkr.taajama OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr.facta_asia | type: TABLE --
-- DROP TABLE IF EXISTS jkr.facta_asia CASCADE;
CREATE TABLE jkr.facta_asia (
	id serial NOT NULL,
	kohde_id integer NOT NULL,
	hakusanat text,
	tapahumalaji text,
	paatoslaji text,
	paattaja text,
	paatostulos text,
	kasittelija text,
	paatettavaksipvm date,
	kasittelypvm date,
	paatospvm date,
	paatosvoimassapvm date,
	paatospykala text,
	sisalto text,
	perustelu text,
	lisatieto text,
	CONSTRAINT paatos_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr.facta_asia OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr.pohjavesialue | type: TABLE --
-- DROP TABLE IF EXISTS jkr.pohjavesialue CASCADE;
CREATE TABLE jkr.pohjavesialue (
	id serial NOT NULL,
	geom geometry,
	CONSTRAINT pohjavesialue_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr.pohjavesialue OWNER TO jkr_admin;
-- ddl-end --

-- object: jatetyyppi_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.velvoitemalli DROP CONSTRAINT IF EXISTS jatetyyppi_fk CASCADE;
ALTER TABLE jkr.velvoitemalli ADD CONSTRAINT jatetyyppi_fk FOREIGN KEY (jatetyyppi_id)
REFERENCES jkr_koodistot.jatetyyppi (id) MATCH FULL
ON DELETE RESTRICT ON UPDATE CASCADE;
-- ddl-end --

-- object: geom_idx | type: INDEX --
-- DROP INDEX IF EXISTS jkr.geom_idx CASCADE;
CREATE INDEX geom_idx ON jkr.kohde
USING gist
(
	geom
);
-- ddl-end --

-- object: jkr.jatteenkuljetusalue | type: TABLE --
-- DROP TABLE IF EXISTS jkr.jatteenkuljetusalue CASCADE;
CREATE TABLE jkr.jatteenkuljetusalue (
	id serial NOT NULL,
	geom geometry(POLYGON, 3878),
	CONSTRAINT jatteenkuljetusalue_pk PRIMARY KEY (id)
);
-- ddl-end --
COMMENT ON TABLE jkr.jatteenkuljetusalue IS E'näiden alueiden ulkopuoliset kiinteistöt liittyvät aluejätekeräykseen';
-- ddl-end --
ALTER TABLE jkr.jatteenkuljetusalue OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr.keskeytys | type: TABLE --
-- DROP TABLE IF EXISTS jkr.keskeytys CASCADE;
CREATE TABLE jkr.keskeytys (
	id serial NOT NULL,
	alkupvm date,
	loppupvm date,
	selite text,
	sopimus_id integer NOT NULL,
	CONSTRAINT keskeytys_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr.keskeytys OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr.tyhjennysvali | type: TABLE --
-- DROP TABLE IF EXISTS jkr.tyhjennysvali CASCADE;
CREATE TABLE jkr.tyhjennysvali (
	id serial NOT NULL,
	alkuvko smallint DEFAULT 1,
	loppuvko smallint DEFAULT 53,
	tyhjennysvali smallint NOT NULL,
	sopimus_id integer NOT NULL,
	CONSTRAINT tyhjennysvali_pk PRIMARY KEY (id)
);
-- ddl-end --
COMMENT ON COLUMN jkr.tyhjennysvali.tyhjennysvali IS E'tyhjennysväli viikoissa';
-- ddl-end --
ALTER TABLE jkr.tyhjennysvali OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr_osoite.katu | type: TABLE --
-- DROP TABLE IF EXISTS jkr_osoite.katu CASCADE;
CREATE TABLE jkr_osoite.katu (
	id serial NOT NULL,
	katunimi_fi text,
	katunimi_sv text,
	kunta_koodi char(3) NOT NULL,
	CONSTRAINT katu_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr_osoite.katu OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr.osoite | type: TABLE --
-- DROP TABLE IF EXISTS jkr.osoite CASCADE;
CREATE TABLE jkr.osoite (
	id serial NOT NULL,
	osoitenumero text,
	katu_id integer NOT NULL,
	rakennus_id integer NOT NULL,
	posti_numero char(5),
	CONSTRAINT osoite_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr.osoite OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr_osoite.kunta | type: TABLE --
-- DROP TABLE IF EXISTS jkr_osoite.kunta CASCADE;
CREATE TABLE jkr_osoite.kunta (
	koodi char(3) NOT NULL,
	nimi_fi text,
	nimi_sv text,
	CONSTRAINT kunta_pk PRIMARY KEY (koodi)
);
-- ddl-end --
ALTER TABLE jkr_osoite.kunta OWNER TO jkr_admin;
-- ddl-end --

-- object: kunta_fk | type: CONSTRAINT --
-- ALTER TABLE jkr_osoite.katu DROP CONSTRAINT IF EXISTS kunta_fk CASCADE;
ALTER TABLE jkr_osoite.katu ADD CONSTRAINT kunta_fk FOREIGN KEY (kunta_koodi)
REFERENCES jkr_osoite.kunta (koodi) MATCH FULL
ON DELETE RESTRICT ON UPDATE CASCADE;
-- ddl-end --

-- object: katu_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.osoite DROP CONSTRAINT IF EXISTS katu_fk CASCADE;
ALTER TABLE jkr.osoite ADD CONSTRAINT katu_fk FOREIGN KEY (katu_id)
REFERENCES jkr_osoite.katu (id) MATCH FULL
ON DELETE RESTRICT ON UPDATE CASCADE;
-- ddl-end --

-- object: prt_uidx | type: INDEX --
-- DROP INDEX IF EXISTS jkr.prt_uidx CASCADE;
CREATE UNIQUE INDEX prt_uidx ON jkr.rakennus
USING btree
(
	prt
);
-- ddl-end --

-- object: katunimi_fi_idx | type: INDEX --
-- DROP INDEX IF EXISTS jkr_osoite.katunimi_fi_idx CASCADE;
CREATE UNIQUE INDEX katunimi_fi_idx ON jkr_osoite.katu
USING btree
(
	kunta_koodi,
	katunimi_fi
);
-- ddl-end --

-- object: katunimi_sv_idx | type: INDEX --
-- DROP INDEX IF EXISTS jkr_osoite.katunimi_sv_idx CASCADE;
CREATE UNIQUE INDEX katunimi_sv_idx ON jkr_osoite.katu
USING btree
(
	kunta_koodi,
	katunimi_sv
);
-- ddl-end --

-- object: rakennus_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.osoite DROP CONSTRAINT IF EXISTS rakennus_fk CASCADE;
ALTER TABLE jkr.osoite ADD CONSTRAINT rakennus_fk FOREIGN KEY (rakennus_id)
REFERENCES jkr.rakennus (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: jkr.qgis_notify | type: FUNCTION --
-- DROP FUNCTION IF EXISTS jkr.qgis_notify() CASCADE;
CREATE FUNCTION jkr.qgis_notify ()
	RETURNS trigger
	LANGUAGE plpgsql
	VOLATILE 
	CALLED ON NULL INPUT
	SECURITY INVOKER
	PARALLEL UNSAFE
	COST 1
	AS $$
BEGIN NOTIFY qgis;
RETURN NULL;
END; 
$$;
-- ddl-end --
ALTER FUNCTION jkr.qgis_notify() OWNER TO jkr_admin;
-- ddl-end --

-- object: notify_qgis_edit | type: TRIGGER --
-- DROP TRIGGER IF EXISTS notify_qgis_edit ON jkr.kohde CASCADE;
CREATE TRIGGER notify_qgis_edit
	AFTER INSERT OR DELETE OR TRUNCATE OR UPDATE
	ON jkr.kohde
	FOR EACH STATEMENT
	EXECUTE PROCEDURE jkr.qgis_notify();
-- ddl-end --

-- object: jkr.create_kohde_geom | type: FUNCTION --
-- DROP FUNCTION IF EXISTS jkr.create_kohde_geom(integer) CASCADE;
CREATE FUNCTION jkr.create_kohde_geom (IN kohde_id integer)
	RETURNS geometry
	LANGUAGE sql
	VOLATILE 
	CALLED ON NULL INPUT
	SECURITY INVOKER
	PARALLEL UNSAFE
	COST 1
	AS $$
select
  ST_ConvexHull(ST_Collect(buf_geom))
from (
  select
    st_buffer(r.geom, 8) buf_geom
  from
    jkr.kohde k
    join jkr.kohteen_rakennukset kr
      on k.id = kr.kohde_id
    join jkr.rakennus r
      on kr.rakennus_id = r.id
  where k.id = $1
) bufferoidut
;

$$;
-- ddl-end --
ALTER FUNCTION jkr.create_kohde_geom(integer) OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr.update_kohde_geom | type: FUNCTION --
-- DROP FUNCTION IF EXISTS jkr.update_kohde_geom() CASCADE;
CREATE FUNCTION jkr.update_kohde_geom ()
	RETURNS trigger
	LANGUAGE plpgsql
	VOLATILE 
	CALLED ON NULL INPUT
	SECURITY INVOKER
	PARALLEL UNSAFE
	COST 1
	AS $$
begin
	if (TG_OP = 'INSERT') THEN
		update jkr.kohde
		set geom = jkr.create_kohde_geom(new.kohde_id)
		where id = new.kohde_id;
  elsif (TG_OP = 'DELETE') THEN
		update jkr.kohde
		set geom = jkr.create_kohde_geom(old.kohde_id)
		where id = old.kohde_id;
  elsif (TG_OP = 'UPDATE' AND old.kohde_id <> new.kohde_id) THEN
		update jkr.kohde
		set geom = jkr.create_kohde_geom(new.kohde_id)
		where id = old.kohde_id;
  elsif (TG_OP = 'TRUNCATE') THEN
		update jkr.kohde
		set geom = null;
	end if;
  RETURN NULL;
end;
$$;
-- ddl-end --
ALTER FUNCTION jkr.update_kohde_geom() OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr_koodistot.kohdetyyppi | type: TABLE --
-- DROP TABLE IF EXISTS jkr_koodistot.kohdetyyppi CASCADE;
CREATE TABLE jkr_koodistot.kohdetyyppi (
	id serial NOT NULL,
	selite text NOT NULL,
	CONSTRAINT kohdetyyppi_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr_koodistot.kohdetyyppi OWNER TO jkr_admin;
-- ddl-end --

INSERT INTO jkr_koodistot.kohdetyyppi (id, selite) VALUES (E'1', E'kiinteistö');
-- ddl-end --
INSERT INTO jkr_koodistot.kohdetyyppi (id, selite) VALUES (E'2', E'putkikeräys');
-- ddl-end --
INSERT INTO jkr_koodistot.kohdetyyppi (id, selite) VALUES (E'3', E'lähikeräys');
-- ddl-end --
INSERT INTO jkr_koodistot.kohdetyyppi (id, selite) VALUES (E'4', E'aluekeräys');
-- ddl-end --

-- object: kohdetyyppi_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.kohde DROP CONSTRAINT IF EXISTS kohdetyyppi_fk CASCADE;
ALTER TABLE jkr.kohde ADD CONSTRAINT kohdetyyppi_fk FOREIGN KEY (kohdetyyppi_id)
REFERENCES jkr_koodistot.kohdetyyppi (id) MATCH FULL
ON DELETE RESTRICT ON UPDATE CASCADE;
-- ddl-end --

-- object: kohdetyyppi_selite_uidx | type: INDEX --
-- DROP INDEX IF EXISTS jkr_koodistot.kohdetyyppi_selite_uidx CASCADE;
CREATE UNIQUE INDEX kohdetyyppi_selite_uidx ON jkr_koodistot.kohdetyyppi
USING btree
(
	selite
);
-- ddl-end --

-- object: jkr_koodistot.tiedontuottaja | type: TABLE --
-- DROP TABLE IF EXISTS jkr_koodistot.tiedontuottaja CASCADE;
CREATE TABLE jkr_koodistot.tiedontuottaja (
	tunnus char(3) NOT NULL,
	nimi text NOT NULL,
	CONSTRAINT tiedontuottaja_pk PRIMARY KEY (tunnus)
);
-- ddl-end --
ALTER TABLE jkr_koodistot.tiedontuottaja OWNER TO jkr_admin;
-- ddl-end --

-- object: tunnus_uidx | type: INDEX --
-- DROP INDEX IF EXISTS jkr_koodistot.tunnus_uidx CASCADE;
CREATE UNIQUE INDEX tunnus_uidx ON jkr_koodistot.tiedontuottaja
USING btree
(
	tunnus
);
-- ddl-end --

-- object: nimi_uidx | type: INDEX --
-- DROP INDEX IF EXISTS jkr_koodistot.nimi_uidx CASCADE;
CREATE UNIQUE INDEX nimi_uidx ON jkr_koodistot.tiedontuottaja
USING btree
(
	nimi
);
-- ddl-end --

-- -- object: public.postgres_fdw_validator | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS public.postgres_fdw_validator(text[],oid) CASCADE;
-- CREATE FUNCTION public.postgres_fdw_validator (_param1 text[], _param2 oid)
-- 	RETURNS void
-- 	LANGUAGE c
-- 	VOLATILE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL UNSAFE
-- 	COST 1
-- 	AS '$libdir/postgres_fdw', 'postgres_fdw_validator';
-- -- ddl-end --
-- ALTER FUNCTION public.postgres_fdw_validator(text[],oid) OWNER TO postgres;
-- -- ddl-end --
-- 
-- -- object: public.postgres_fdw_handler | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS public.postgres_fdw_handler() CASCADE;
-- CREATE FUNCTION public.postgres_fdw_handler ()
-- 	RETURNS fdw_handler
-- 	LANGUAGE c
-- 	VOLATILE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL UNSAFE
-- 	COST 1
-- 	AS '$libdir/postgres_fdw', 'postgres_fdw_handler';
-- -- ddl-end --
-- ALTER FUNCTION public.postgres_fdw_handler() OWNER TO postgres;
-- -- ddl-end --
-- 
-- -- object: postgres_fdw | type: FOREIGN DATA WRAPPER --
-- -- DROP FOREIGN DATA WRAPPER IF EXISTS postgres_fdw CASCADE;
-- CREATE FOREIGN DATA WRAPPER postgres_fdw
-- HANDLER public.postgres_fdw_handler
-- VALIDATOR public.postgres_fdw_validator;
-- -- ddl-end --
-- ALTER FOREIGN DATA WRAPPER postgres_fdw OWNER TO postgres;
-- -- ddl-end --
-- 
-- -- object: facta_pg | type: SERVER --
-- -- DROP SERVER IF EXISTS facta_pg CASCADE;
-- CREATE SERVER facta_pg
-- FOREIGN DATA WRAPPER postgres_fdw
-- OPTIONS (dbname 'facta',host 'localhost',port '5432');
-- -- ddl-end --
-- ALTER SERVER facta_pg OWNER TO postgres;
-- -- ddl-end --
-- 
-- -- object: public.geometry | type: TYPE --
-- -- DROP TYPE IF EXISTS public.geometry CASCADE;
-- CREATE TYPE public.geometry (
-- 	, INTERNALLENGTH = VARIABLE
-- 	, ALIGNMENT = double precision
-- 	, STORAGE = main
-- 	, DELIMITER = ':'
-- 	, CATEGORY = 'U'
-- );
-- -- ddl-end --
-- ALTER TYPE public.geometry OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON TYPE public.geometry IS E'postgis type: The type representing spatial features with planar coordinate systems.';
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_aluepiste | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_aluepiste CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_aluepiste (
-- 	kg_kjhaluepiste double precision NOT NULL,
-- 	c_nimi_fin character varying(100),
-- 	c_nimi_swe character varying(100),
-- 	i_pkoord double precision,
-- 	i_ikoord double precision,
-- 	i_xkoord double precision,
-- 	i_ykoord double precision,
-- 	i_nkoord double precision,
-- 	i_ekoord double precision,
-- 	i_nkoord_tm35fin double precision,
-- 	i_ekoord_tm35fin double precision,
-- 	c_kuka character varying(16),
-- 	c_milloin character varying(17),
-- 	c_kunta character varying(3),
-- 	geom public.geometry
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_aluepiste');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_aluepiste OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_aluepisteen_jatteet | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_aluepisteen_jatteet CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_aluepisteen_jatteet (
-- 	gid integer NOT NULL,
-- 	kg_kjhaluepiste_jate double precision,
-- 	kg_kjhaluepiste double precision,
-- 	c_nimi_fin character varying(100),
-- 	c_nimi_swe character varying(100),
-- 	c_jatelaji character varying(3),
-- 	c_astiatyyppi character varying(3),
-- 	i_astiatilavuus double precision,
-- 	i_tyhjennyskerrat double precision,
-- 	i_astialkm double precision,
-- 	c_kuka character varying(16),
-- 	c_milloin character varying(17)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_aluepisteen_jatteet');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_aluepisteen_jatteet OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_aluepisteen_osoitteet | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_aluepisteen_osoitteet CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_aluepisteen_osoitteet (
-- 	gid integer NOT NULL,
-- 	kg_kjhaluepiste double precision,
-- 	kg_kosoite double precision,
-- 	c_nimi_fin character varying(100),
-- 	c_nimi_swe character varying(100),
-- 	c_osoitenro character varying(15),
-- 	c_lahiosoite_suomi character varying(4000),
-- 	c_lahiosoite_ruotsi character varying(4000),
-- 	c_postinro character varying(5),
-- 	i_osnro1 double precision,
-- 	c_oskirj1 character varying(1),
-- 	i_osnro2 double precision,
-- 	c_oskirj2 character varying(1),
-- 	c_ostyyppi character varying(1),
-- 	c_olotila character varying(1),
-- 	postitmp_fin character varying(502),
-- 	postitmp_swe character varying(502),
-- 	c_kuka character varying(16),
-- 	c_milloin character varying(17)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_aluepisteen_osoitteet');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_aluepisteen_osoitteet OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_asiakk_koht_tapahtumat | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_asiakk_koht_tapahtumat CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_asiakk_koht_tapahtumat (
-- 	gid integer NOT NULL,
-- 	kg_kjhtapahtuma double precision NOT NULL,
-- 	kg_kjhasiakkuus double precision NOT NULL
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_asiakk_koht_tapahtumat');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_asiakk_koht_tapahtumat OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_asiakkuuden_kohde | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_asiakkuuden_kohde CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_asiakkuuden_kohde (
-- 	gid integer NOT NULL,
-- 	kg_kjhasiakkuus double precision,
-- 	kg_khallyks double precision,
-- 	kg_kjhkohde double precision,
-- 	kg_kjhaluepiste double precision,
-- 	c_kiinteistotunnus character varying(17),
-- 	c_hallyks_kunta character varying(3),
-- 	c_sijainti character varying(3),
-- 	c_ryhma character varying(4),
-- 	c_yksikko character varying(4),
-- 	c_kayttokelvoton character varying(1),
-- 	c_kelvoton_saakka_pvm date,
-- 	d_etaisyys_jatepisteeseen double precision,
-- 	c_lisatieto bytea,
-- 	c_kunta character varying(3),
-- 	i_pkoord double precision,
-- 	i_ikoord double precision,
-- 	i_xkoord double precision,
-- 	i_ykoord double precision,
-- 	i_nkoord double precision,
-- 	i_ekoord double precision,
-- 	i_nkoord_tm35fin double precision,
-- 	i_ekoord_tm35fin double precision,
-- 	c_kuka character varying(16),
-- 	c_milloin character varying(17),
-- 	c_kohde_lisatieto bytea,
-- 	c_nimis character varying(50),
-- 	c_nimir character varying(50),
-- 	c_osoitenro character varying(15),
-- 	c_lahiosoite_suomi character varying(4000),
-- 	c_lahiosoite_ruotsi character varying(4000),
-- 	c_postinro character varying(5),
-- 	i_osnro1 double precision,
-- 	c_oskirj1 character varying(1),
-- 	i_osnro2 double precision,
-- 	c_oskirj2 character varying(1),
-- 	c_ostyyppi character varying(1),
-- 	c_olotila character varying(1),
-- 	postitmp_fin character varying(502),
-- 	postitmp_swe character varying(502),
-- 	c_osapuolet character varying(4000),
-- 	c_asiamiehet character varying(4000),
-- 	geom geometry(POINT, 3878)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_asiakkuuden_kohde');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_asiakkuuden_kohde OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_asian_kasittely | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_asian_kasittely CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_asian_kasittely (
-- 	kg_kjhtapahtuma double precision NOT NULL,
-- 	kg_paatapahtuma double precision,
-- 	kg_edkjhtapahtuma double precision,
-- 	c_tapahtumalaji character varying(3),
-- 	c_asiantunnus character varying(85),
-- 	i_tunnusvuosi double precision,
-- 	i_tunnusnumero double precision,
-- 	c_tunnustyyppi character varying(3),
-- 	c_kuvaus bytea,
-- 	c_kasittelija character varying(3),
-- 	c_kasittelypvm date,
-- 	c_saappvm date,
-- 	c_vireillepvm date,
-- 	c_diaari character varying(30),
-- 	c_tilanne character varying(3),
-- 	c_tilannepvm date,
-- 	c_sisalto bytea,
-- 	i_kayttajalkm double precision,
-- 	i_asukaslkm double precision,
-- 	c_tarkistettupvm date,
-- 	c_kaytto character varying(3),
-- 	i_kayttopaivat double precision,
-- 	c_laskutunnus character varying(20),
-- 	d_laskunsumma double precision,
-- 	c_rakennuskunto character varying(3),
-- 	d_lietemaara double precision,
-- 	i_sailiotilavuus double precision,
-- 	i_lietetyhjennys double precision,
-- 	c_tiedtapa character varying(3),
-- 	c_yhteysvaline character varying(3),
-- 	c_lahetyspvm date,
-- 	c_tiedoksisaantipvm date,
-- 	c_viimvalituspvm date,
-- 	c_paatoslaji character varying(3),
-- 	c_paattaja character varying(3),
-- 	c_paatostulos character varying(3),
-- 	i_paatospykala double precision,
-- 	c_paatospvm date,
-- 	c_paatosvoimassapvm date,
-- 	c_maarapvm date,
-- 	d_kasittelyaika double precision,
-- 	d_matka_aika double precision,
-- 	d_matka double precision,
-- 	c_lasna bytea,
-- 	c_perustelu bytea,
-- 	c_oikeusohjeet bytea,
-- 	c_jakelu bytea,
-- 	c_liitteet bytea,
-- 	i_salassa double precision,
-- 	c_salassaryhma character varying(20),
-- 	c_kunta character varying(3),
-- 	i_pkoord double precision,
-- 	i_ikoord double precision,
-- 	i_xkoord double precision,
-- 	i_ykoord double precision,
-- 	i_nkoord double precision,
-- 	i_ekoord double precision,
-- 	i_nkoord_tm35fin double precision,
-- 	i_ekoord_tm35fin double precision,
-- 	c_kuka character varying(16),
-- 	c_milloin character varying(17),
-- 	c_paatosantopvm date,
-- 	c_paatettavaksipvm date,
-- 	c_palautapvm date,
-- 	c_hyvaksyntapvm date,
-- 	c_muutosviranomainen character varying(3),
-- 	c_lainvoimapvm date,
-- 	i_sekajate double precision,
-- 	i_biojate double precision,
-- 	i_liete double precision,
-- 	i_muujate double precision,
-- 	c_sovittupvm date,
-- 	i_viranomainen double precision,
-- 	c_hakusanat character varying(250),
-- 	c_paatoslukittu character varying(1),
-- 	geom geometry(POINT, 3878)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_asian_kasittely');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_asian_kasittely OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_asioiden_osapuolet | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_asioiden_osapuolet CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_asioiden_osapuolet (
-- 	gid integer NOT NULL,
-- 	kg_kjhtapahtuma double precision,
-- 	c_asiantunnus character varying(85),
-- 	i_tunnusvuosi double precision,
-- 	i_tunnusnumero double precision,
-- 	c_tunnustyyppi character varying(3),
-- 	c_rooli character varying(3),
-- 	c_sukunimi character varying(300),
-- 	c_etunimet character varying(110),
-- 	c_lahiosoite character varying(50),
-- 	c_postinro character varying(5),
-- 	c_puhnro character varying(20),
-- 	c_sahkopos character varying(100),
-- 	c_laji character varying(3),
-- 	c_sotu character varying(11),
-- 	c_ytunnus character varying(9),
-- 	c_kotikunta character varying(3),
-- 	c_onko_kuollut character varying(1),
-- 	postitmp_fin character varying(502),
-- 	postitmp_swe character varying(502),
-- 	c_laskutustunnus character varying(30),
-- 	c_tyyppi character varying(3),
-- 	c_asiamies character varying(202)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_asioiden_osapuolet');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_asioiden_osapuolet OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_jatevesijarjestelma | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_jatevesijarjestelma CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_jatevesijarjestelma (
-- 	gid integer NOT NULL,
-- 	kg_kjhasiakkuus double precision,
-- 	c_vesijohtoverkko character varying(1),
-- 	c_viemarialue character varying(1),
-- 	c_viemari_laajenemis_suun character varying(1),
-- 	c_tyyppi character varying(1),
-- 	c_lahde character varying(1),
-- 	c_viemariverkossa character varying(1),
-- 	c_wc character varying(1),
-- 	c_sijaintikunta character varying(3),
-- 	c_kiinteistotunnus character varying(17),
-- 	c_jarjestelmannimi character varying(50),
-- 	c_jarjestelmaan_wc character varying(1),
-- 	c_jarjestelmaan_harmaat character varying(1),
-- 	c_ei_lietekaivoa character varying(1),
-- 	c_esikasittely character varying(1),
-- 	c_lietteenkasittely character varying(1),
-- 	c_omatoiminensaakkapvm date,
-- 	c_jatevesiyhtio character varying(3),
-- 	c_menettelytapa character varying(3),
-- 	c_kasittelytapa character varying(3),
-- 	c_kuvaus bytea,
-- 	c_kunta character varying(3),
-- 	i_pkoord double precision,
-- 	i_ikoord double precision,
-- 	i_xkoord double precision,
-- 	i_ykoord double precision,
-- 	i_nkoord double precision,
-- 	i_ekoord double precision,
-- 	i_nkoord_tm35fin double precision,
-- 	i_ekoord_tm35fin double precision,
-- 	kg_kjhlietekasittely double precision
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_jatevesijarjestelma');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_jatevesijarjestelma OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_kimppa | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_kimppa CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_kimppa (
-- 	kg_kjhkimppa double precision NOT NULL,
-- 	i_pkoord double precision,
-- 	i_ikoord double precision,
-- 	i_xkoord double precision,
-- 	i_ykoord double precision,
-- 	i_nkoord double precision,
-- 	i_ekoord double precision,
-- 	i_nkoord_tm35fin double precision,
-- 	i_ekoord_tm35fin double precision,
-- 	c_kunta character varying(3),
-- 	c_kiinteistotunnus character varying(17),
-- 	hallyks_kunta character varying(3),
-- 	c_sijainti character varying(3),
-- 	c_ryhma character varying(4),
-- 	c_yksikko character varying(4),
-- 	c_kuka character varying(16),
-- 	c_milloin character varying(17),
-- 	c_osapuolet character varying(4000),
-- 	c_asiamiehet character varying(4000),
-- 	geom geometry(POINT, 3878)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_kimppa');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_kimppa OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_kimppa_asiakkuus | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_kimppa_asiakkuus CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_kimppa_asiakkuus (
-- 	gid integer NOT NULL,
-- 	kg_kjhkimppa double precision,
-- 	kg_kjhasiakkuus double precision
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_kimppa_asiakkuus');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_kimppa_asiakkuus OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_kimppa_jatteet | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_kimppa_jatteet CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_kimppa_jatteet (
-- 	gid integer NOT NULL,
-- 	kg_kjhkimppa_jate double precision,
-- 	kg_kjhkimppa double precision,
-- 	c_jatelaji character varying(3),
-- 	c_astiatyyppi character varying(3),
-- 	i_astiatilavuus double precision,
-- 	i_tyhjennyskerrat double precision,
-- 	c_kiinteistotunnus character varying(17),
-- 	hallyks_kunta character varying(3),
-- 	c_sijainti character varying(3),
-- 	c_ryhma character varying(4),
-- 	c_yksikko character varying(4),
-- 	c_kuka character varying(16),
-- 	c_milloin character varying(17)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_kimppa_jatteet');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_kimppa_jatteet OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_kimppa_osapuolet | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_kimppa_osapuolet CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_kimppa_osapuolet (
-- 	gid integer NOT NULL,
-- 	kg_kasia_osap double precision,
-- 	kg_kjhkimppa double precision,
-- 	kg_kosap_osoite double precision,
-- 	kg_kyhteysh double precision,
-- 	c_rooli character varying(3),
-- 	c_kiinteistotunnus character varying(17),
-- 	hallyks_kunta character varying(3),
-- 	c_sijainti character varying(3),
-- 	c_ryhma character varying(4),
-- 	c_yksikko character varying(4),
-- 	c_sukunimi character varying(300),
-- 	c_etunimet character varying(110),
-- 	c_lahiosoite character varying(50),
-- 	c_postinro character varying(5),
-- 	c_puhnro character varying(20),
-- 	c_sahkopos character varying(100),
-- 	c_laji character varying(3),
-- 	c_sotu character varying(11),
-- 	c_ytunnus character varying(9),
-- 	c_kotikunta character varying(3),
-- 	c_onko_kuollut character varying(1),
-- 	postitmp_fin character varying(502),
-- 	postitmp_swe character varying(502),
-- 	c_laskutustunnus character varying(30),
-- 	c_kuka character varying(16),
-- 	c_milloin character varying(17),
-- 	c_asiamies character varying(202)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_kimppa_osapuolet');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_kimppa_osapuolet OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_kimppa_osoitteet | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_kimppa_osoitteet CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_kimppa_osoitteet (
-- 	gid integer NOT NULL,
-- 	kg_kjhkimppa double precision,
-- 	kg_kosoite double precision,
-- 	c_osoitenro character varying(15),
-- 	c_lahiosoite_suomi character varying(4000),
-- 	c_lahiosoite_ruotsi character varying(4000),
-- 	c_postinro character varying(5),
-- 	i_osnro1 double precision,
-- 	c_oskirj1 character varying(1),
-- 	i_osnro2 double precision,
-- 	c_oskirj2 character varying(1),
-- 	c_ostyyppi character varying(1),
-- 	c_olotila character varying(1),
-- 	c_kiinteistotunnus character varying(17),
-- 	hallyks_kunta character varying(3),
-- 	c_sijainti character varying(3),
-- 	c_ryhma character varying(4),
-- 	c_yksikko character varying(4),
-- 	c_kuka character varying(16),
-- 	c_milloin character varying(17)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_kimppa_osoitteet');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_kimppa_osoitteet OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_kohde | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_kohde CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_kohde (
-- 	kg_kjhkohde double precision NOT NULL
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_kohde');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_kohde OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_kohteen_hallintayksikot | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_kohteen_hallintayksikot CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_kohteen_hallintayksikot (
-- 	gid integer NOT NULL,
-- 	kg_kjhkohde double precision,
-- 	kg_khallyks double precision,
-- 	c_sijkunta character varying(3),
-- 	c_kiinteistotunnus character varying(17),
-- 	c_kunta character varying(3),
-- 	c_sijainti character varying(3),
-- 	c_ryhma character varying(4),
-- 	c_yksikko character varying(4),
-- 	c_vaihe character varying(1)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_kohteen_hallintayksikot');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_kohteen_hallintayksikot OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_kohteen_rakennukset | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_kohteen_rakennukset CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_kohteen_rakennukset (
-- 	gid integer NOT NULL,
-- 	kg_kjhkohde double precision,
-- 	kg_krakenn double precision,
-- 	i_pyraknro double precision,
-- 	c_vtj_prt character varying(10),
-- 	c_olotila character varying(1),
-- 	c_rakennusluokka character varying(4),
-- 	c_kayttark character varying(3),
-- 	c_valmpvm date,
-- 	i_kokala double precision,
-- 	c_lahiosoite_suomi character varying(4000),
-- 	c_lahiosoite_ruotsi character varying(4000),
-- 	c_postinro character varying(5),
-- 	postitmp_fin character varying(502),
-- 	postitmp_swe character varying(502)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_kohteen_rakennukset');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_kohteen_rakennukset OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.jh_lietteenkasittely_osap | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_lietteenkasittely_osap CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_lietteenkasittely_osap (
-- 	gid integer NOT NULL,
-- 	kg_asia double precision,
-- 	kg_kasia_osap double precision,
-- 	c_sukunimi character varying(300),
-- 	c_etunimet character varying(110),
-- 	c_lahiosoite character varying(50),
-- 	c_postinro character varying(5),
-- 	c_puhnro character varying(20),
-- 	c_sahkopos character varying(100),
-- 	c_laji character varying(3),
-- 	c_sotu character varying(11),
-- 	c_ytunnus character varying(9),
-- 	c_kotikunta character varying(3),
-- 	c_onko_kuollut character varying(1),
-- 	postitmp_fin character varying(502),
-- 	postitmp_swe character varying(502),
-- 	c_laskutustunnus character varying(30)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_lietteenkasittely_osap');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_lietteenkasittely_osap OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.kiinteisto | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.kiinteisto CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.kiinteisto (
-- 	kg_kkiint double precision NOT NULL,
-- 	c_kunta character varying(3),
-- 	c_sijainti character varying(3),
-- 	c_ryhma character varying(4),
-- 	c_yksikko character varying(4),
-- 	kiinteistotunnus character varying(17),
-- 	i_pkoord double precision,
-- 	i_ikoord double precision,
-- 	i_xkoord double precision,
-- 	i_ykoord double precision,
-- 	i_nkoord double precision,
-- 	i_ekoord double precision,
-- 	i_nkoord_tm35fin double precision,
-- 	i_ekoord_tm35fin double precision,
-- 	c_reklaji character varying(1),
-- 	c_olotila character varying(1),
-- 	c_nimi character varying(30),
-- 	c_kayttota character varying(10),
-- 	c_ktarsel character varying(255),
-- 	i_kokopala double precision,
-- 	i_maapala double precision,
-- 	i_vesipala double precision,
-- 	i_laskpala double precision,
-- 	c_rekpvm timestamp with time zone,
-- 	c_poistpvm timestamp with time zone,
-- 	kg_ylekiint double precision,
-- 	c_kaavatjlaji character varying(1),
-- 	c_palstan_maapala double precision,
-- 	c_palstan_vesipala double precision,
-- 	c_palstan_pintaala double precision,
-- 	c_palstan_rekpvm timestamp with time zone,
-- 	c_rekpvmlaji character varying(1),
-- 	c_ktj_reklaji character varying(2),
-- 	c_osaluku character varying(8),
-- 	c_manttaali character varying(8),
-- 	c_ktj_kayttota character varying(8),
-- 	c_ktj_mhkayttota character varying(8),
-- 	c_ktj_kmhtarsel character varying(255),
-- 	c_ktj_milloin timestamp with time zone,
-- 	c_arkisnro character varying(160),
-- 	c_poistpvmlaji character varying(1),
-- 	kg_khallyks double precision,
-- 	c_vsopnro character varying(8),
-- 	c_alkirpvm timestamp with time zone,
-- 	c_vuoalpvm timestamp with time zone,
-- 	c_vuolopvm timestamp with time zone,
-- 	c_vsiirpvm timestamp with time zone,
-- 	c_vuokramk character varying(23),
-- 	c_myyhinta character varying(23),
-- 	c_lisatiet bytea,
-- 	c_katukkod character varying(3),
-- 	c_sijkunta character varying(3),
-- 	geom geometry(POINT, 3878)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'kiinteisto');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.kiinteisto OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.kiinteiston_omistajat | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.kiinteiston_omistajat CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.kiinteiston_omistajat (
-- 	gid integer NOT NULL,
-- 	kg_kkiint double precision,
-- 	kg_khallyks double precision,
-- 	kiinteistotunnus character varying(17),
-- 	maaraalatunnus character varying(23),
-- 	c_kunta character varying(3),
-- 	c_sijainti character varying(3),
-- 	c_ryhma character varying(4),
-- 	c_yksikko character varying(4),
-- 	c_hallkirj character varying(1),
-- 	c_halltunn character varying(4),
-- 	c_sukunimi character varying(100),
-- 	c_etunimet character varying(110),
-- 	c_lahiosoite character varying(271),
-- 	c_postinro character varying(5),
-- 	c_laji character varying(2),
-- 	c_sotu character varying(11),
-- 	c_lytunn character varying(11),
-- 	c_kotikunt character varying(3),
-- 	c_onko_kuollut character varying(1),
-- 	c_lainhpvm date,
-- 	c_pykala character varying(7),
-- 	c_saantpvm date,
-- 	c_osuus character varying(19),
-- 	i_jarjnro double precision,
-- 	c_yhttied1 character varying(100),
-- 	c_ratkaisu character varying(1),
-- 	c_ratkaisupvm date,
-- 	postitmp_fin character varying(502),
-- 	postitmp_swe character varying(502),
-- 	c_onko_asiamies character varying(1),
-- 	c_saantoselitys character varying(500),
-- 	c_saalaatu character varying(2),
-- 	c_asianumero character varying(30),
-- 	c_asianlaatu character varying(4),
-- 	c_sijkunta character varying(3),
-- 	c_onko_ulkomainen_osoite character varying(1),
-- 	c_ulkomainen_osoite1 character varying(101),
-- 	c_ulkomainen_osoite2 character varying(101),
-- 	c_ulkomainen_osoite_maa character varying(50),
-- 	geom geometry(POINT, 3878)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'kiinteiston_omistajat');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.kiinteiston_omistajat OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.kiinteistot_alueet | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.kiinteistot_alueet CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.kiinteistot_alueet (
-- 	gid integer NOT NULL,
-- 	kg_kkiint double precision,
-- 	c_kunta character varying(3),
-- 	c_sijainti character varying(3),
-- 	c_ryhma character varying(4),
-- 	c_yksikko character varying(4),
-- 	kiinteistotunnus character varying(17),
-- 	i_pkoord double precision,
-- 	i_ikoord double precision,
-- 	i_xkoord double precision,
-- 	i_ykoord double precision,
-- 	i_nkoord double precision,
-- 	i_ekoord double precision,
-- 	i_nkoord_tm35fin double precision,
-- 	i_ekoord_tm35fin double precision,
-- 	c_reklaji character varying(1),
-- 	c_olotila character varying(1),
-- 	c_nimi character varying(30),
-- 	c_kayttota character varying(10),
-- 	c_ktarsel character varying(255),
-- 	i_kokopala double precision,
-- 	i_maapala double precision,
-- 	i_vesipala double precision,
-- 	i_laskpala double precision,
-- 	c_rekpvm date,
-- 	c_poistpvm date,
-- 	kg_ylekiint double precision,
-- 	c_kaavatjlaji character varying(1),
-- 	c_palstan_maapala double precision,
-- 	c_palstan_vesipala double precision,
-- 	c_palstan_pintaala double precision,
-- 	c_palstan_rekpvm date,
-- 	c_rekpvmlaji character varying(1),
-- 	c_ktj_reklaji character varying(2),
-- 	c_osaluku character varying(8),
-- 	c_manttaali character varying(8),
-- 	c_ktj_kayttota character varying(8),
-- 	c_ktj_mhkayttota character varying(8),
-- 	c_ktj_kmhtarsel character varying(255),
-- 	c_ktj_milloin date,
-- 	c_arkisnro character varying(160),
-- 	c_poistpvmlaji character varying(1),
-- 	kg_khallyks double precision,
-- 	c_vsopnro character varying(8),
-- 	c_alkirpvm date,
-- 	c_vuoalpvm date,
-- 	c_vuolopvm date,
-- 	c_vsiirpvm date,
-- 	c_vuokramk character varying(23),
-- 	c_myyhinta character varying(23),
-- 	c_lisatiet bytea,
-- 	c_katukkod character varying(3),
-- 	c_sijkunta character varying(3),
-- 	geom geometry(MULTIPOLYGON, 3878)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'kiinteistot_alueet');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.kiinteistot_alueet OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.rakennusten_omistajat | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.rakennusten_omistajat CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.rakennusten_omistajat (
-- 	gid integer NOT NULL,
-- 	i_pyraknro double precision,
-- 	c_vtj_prt character varying(10),
-- 	c_vtj_prt_tilanne character varying(1),
-- 	c_kiinteistotunnus character varying(17),
-- 	c_kunta character varying(3),
-- 	c_sijainti character varying(3),
-- 	c_ryhma character varying(4),
-- 	c_yksikko character varying(4),
-- 	kc_raknro character varying(3),
-- 	c_sukunimi character varying(100),
-- 	c_etunimet character varying(110),
-- 	c_lahiosoite character varying(271),
-- 	c_postinro character varying(5),
-- 	c_laji character varying(2),
-- 	c_sotu character varying(11),
-- 	c_lytunn character varying(11),
-- 	c_kotikunt character varying(3),
-- 	c_onko_kuollut character varying(1),
-- 	c_yhttied1 character varying(100),
-- 	postitmp_fin character varying(502),
-- 	postitmp_swe character varying(502),
-- 	c_omistusperuste double precision,
-- 	kg_kosap double precision,
-- 	kg_kyhttied double precision,
-- 	c_olotila character varying(1),
-- 	c_onko_asiamies character varying(1),
-- 	c_onko_ulkomainen_osoite character varying(1),
-- 	c_ulkomainen_osoite1 character varying(101),
-- 	c_ulkomainen_osoite2 character varying(101),
-- 	c_ulkomainen_osoite_maa character varying(50),
-- 	geom geometry(POINT, 3878)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'rakennusten_omistajat');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.rakennusten_omistajat OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.valmiit_rakennukset | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.valmiit_rakennukset CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.valmiit_rakennukset (
-- 	kg_krakenn double precision NOT NULL,
-- 	i_pyraknro double precision,
-- 	c_vtj_prt character varying(10),
-- 	c_vtj_prt_tilanne character varying(1),
-- 	c_kiinteistotunnus character varying(17),
-- 	c_kunta character varying(3),
-- 	c_sijainti character varying(3),
-- 	c_ryhma character varying(4),
-- 	c_yksikko character varying(4),
-- 	kc_raknro character varying(3),
-- 	i_pkoord double precision,
-- 	i_ikoord double precision,
-- 	i_xkoord double precision,
-- 	i_ykoord double precision,
-- 	i_nkoord double precision,
-- 	i_ekoord double precision,
-- 	i_ekoord_tm35fin double precision,
-- 	i_nkoord_tm35fin double precision,
-- 	c_sijepa character varying(1),
-- 	c_kaytopvm date,
-- 	c_valmpvm date,
-- 	c_julkisivu character varying(1),
-- 	i_kokala double precision,
-- 	i_kellalkm double precision,
-- 	i_kerrlkm double precision,
-- 	i_kerrosala double precision,
-- 	i_rakoik_kerrosala double precision,
-- 	i_kellarala double precision,
-- 	d_ashuoala double precision,
-- 	d_myymala double precision,
-- 	d_hoitala double precision,
-- 	d_toimala double precision,
-- 	d_koktila double precision,
-- 	d_opeala double precision,
-- 	d_tuotala double precision,
-- 	d_varala double precision,
-- 	d_muuala double precision,
-- 	c_rakennusluokka character varying(4),
-- 	c_rakennusluokka_tietolahde character varying(20),
-- 	c_kayttark character varying(3),
-- 	c_kaytolo character varying(2),
-- 	c_lammtapa character varying(1),
-- 	c_poltaine character varying(2),
-- 	c_pystlaji character varying(1),
-- 	c_rakeaine character varying(1),
-- 	c_rakentaja character varying(1),
-- 	i_raktilav double precision,
-- 	c_sahko character varying(1),
-- 	c_kaasu character varying(1),
-- 	c_viemari character varying(1),
-- 	c_vesi character varying(1),
-- 	c_lammvesi character varying(1),
-- 	c_hissi character varying(1),
-- 	c_konelvi character varying(1),
-- 	c_apaneeli character varying(1),
-- 	i_talosaun double precision,
-- 	i_uimalkm double precision,
-- 	i_vaeshenk double precision,
-- 	c_viemlii character varying(1),
-- 	c_vesilii character varying(1),
-- 	c_maakalii character varying(1),
-- 	c_sahkolii character varying(1),
-- 	c_kolomtot character varying(10),
-- 	c_kolompvm date,
-- 	c_laarava character varying(1),
-- 	c_lasalain character varying(1),
-- 	c_lahkarav character varying(1),
-- 	c_lahitas character varying(1),
-- 	c_lakotuki character varying(1),
-- 	c_lakulain character varying(1),
-- 	c_lamuuval character varying(1),
-- 	c_tilapais character varying(1),
-- 	c_kantrapl character varying(3),
-- 	c_katepl character varying(3),
-- 	c_lattiapl character varying(3),
-- 	c_osarakpl character varying(3),
-- 	c_palol character varying(10),
-- 	c_palvaara character varying(1),
-- 	c_suojaus character varying(3),
-- 	c_vaeslk character varying(4),
-- 	c_kaapelilii character varying(1),
-- 	c_viimmuutpvm date,
-- 	c_lamaatih character varying(1),
-- 	c_lalkotuki character varying(1),
-- 	i_toimtilkm double precision,
-- 	i_toimtiala double precision,
-- 	c_perpla1 character varying(1),
-- 	c_perpla2 character varying(1),
-- 	c_perpla3 character varying(1),
-- 	c_perpla4 character varying(1),
-- 	c_perpla5 character varying(1),
-- 	c_perpla6 character varying(1),
-- 	c_perpla7 character varying(1),
-- 	c_perpla8 character varying(1),
-- 	c_peruspar character varying(1),
-- 	c_asrahtyyp character varying(1),
-- 	c_uustuolapvm date,
-- 	c_perparlapvm date,
-- 	c_perpapvm date,
-- 	c_kuntarak character varying(1),
-- 	c_raketapa character varying(1),
-- 	c_aspahall character varying(1),
-- 	c_energialuokka character varying(2),
-- 	c_rakennuksen_kommentti bytea,
-- 	i_huoneistojen_lkm double precision,
-- 	d_huonala_summa double precision,
-- 	i_asukkaiden_lkm_rak double precision,
-- 	i_asukkaiden_lkm_alue double precision,
-- 	i_energiatehokkuusluku double precision,
-- 	i_energiatehokkuusluku_kwhm2 double precision,
-- 	c_rakselite character varying(50),
-- 	c_uustuotannonrahoitus character varying(1),
-- 	c_vero_lahetys character varying(1),
-- 	c_vero_lahetettypvm date,
-- 	c_muokkaushetki date,
-- 	geom geometry(POINT, 3878)
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'valmiit_rakennukset');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.valmiit_rakennukset OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: public.postgres_fdw_validator_cp | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS public.postgres_fdw_validator_cp(text[],oid) CASCADE;
-- CREATE FUNCTION public.postgres_fdw_validator_cp (_param1 text[], _param2 oid)
-- 	RETURNS void
-- 	LANGUAGE c
-- 	VOLATILE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL UNSAFE
-- 	COST 1
-- 	AS '$libdir/postgres_fdw', 'postgres_fdw_validator';
-- -- ddl-end --
-- ALTER FUNCTION public.postgres_fdw_validator_cp(text[],oid) OWNER TO postgres;
-- -- ddl-end --
-- 
-- -- object: public.postgres_fdw_handler_cp | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS public.postgres_fdw_handler_cp() CASCADE;
-- CREATE FUNCTION public.postgres_fdw_handler_cp ()
-- 	RETURNS fdw_handler
-- 	LANGUAGE c
-- 	VOLATILE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL UNSAFE
-- 	COST 1
-- 	AS '$libdir/postgres_fdw', 'postgres_fdw_handler';
-- -- ddl-end --
-- ALTER FUNCTION public.postgres_fdw_handler_cp() OWNER TO postgres;
-- -- ddl-end --
-- 
-- -- object: public.postgres_fdw_validator_cp1 | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS public.postgres_fdw_validator_cp1(text[],oid) CASCADE;
-- CREATE FUNCTION public.postgres_fdw_validator_cp1 (_param1 text[], _param2 oid)
-- 	RETURNS void
-- 	LANGUAGE c
-- 	VOLATILE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL UNSAFE
-- 	COST 1
-- 	AS '$libdir/postgres_fdw', 'postgres_fdw_validator';
-- -- ddl-end --
-- ALTER FUNCTION public.postgres_fdw_validator_cp1(text[],oid) OWNER TO postgres;
-- -- ddl-end --
-- 
-- -- object: public.postgres_fdw_handler_cp1 | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS public.postgres_fdw_handler_cp1() CASCADE;
-- CREATE FUNCTION public.postgres_fdw_handler_cp1 ()
-- 	RETURNS fdw_handler
-- 	LANGUAGE c
-- 	VOLATILE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL UNSAFE
-- 	COST 1
-- 	AS '$libdir/postgres_fdw', 'postgres_fdw_handler';
-- -- ddl-end --
-- ALTER FUNCTION public.postgres_fdw_handler_cp1() OWNER TO postgres;
-- -- ddl-end --
-- 
-- -- object: postgres_fdw | type: EXTENSION --
-- -- DROP EXTENSION IF EXISTS postgres_fdw CASCADE;
-- CREATE EXTENSION postgres_fdw
-- ;
-- -- ddl-end --
-- 
-- -- object: postgres@facta_pg | type: USER MAPPING --
-- -- DROP USER MAPPING IF EXISTS FOR postgres SERVER facta_pg;
-- CREATE USER MAPPING FOR postgres
-- SERVER facta_pg
-- OPTIONS (password 'postgres',user 'postgres');
-- -- ddl-end --
-- 
-- object: jkr_osoite.posti | type: TABLE --
-- DROP TABLE IF EXISTS jkr_osoite.posti CASCADE;
CREATE TABLE jkr_osoite.posti (
	numero char(5) NOT NULL,
	nimi_fi text,
	nimi_se text,
	kunta_koodi char(3) NOT NULL,
	CONSTRAINT posti_pk PRIMARY KEY (numero)
);
-- ddl-end --
ALTER TABLE jkr_osoite.posti OWNER TO jkr_admin;
-- ddl-end --

-- object: posti_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.osoite DROP CONSTRAINT IF EXISTS posti_fk CASCADE;
ALTER TABLE jkr.osoite ADD CONSTRAINT posti_fk FOREIGN KEY (posti_numero)
REFERENCES jkr_osoite.posti (numero) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: posti_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.osapuoli DROP CONSTRAINT IF EXISTS posti_fk CASCADE;
ALTER TABLE jkr.osapuoli ADD CONSTRAINT posti_fk FOREIGN KEY (posti_numero)
REFERENCES jkr_osoite.posti (numero) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: uidx_osapuoli_facta_id | type: INDEX --
-- DROP INDEX IF EXISTS jkr.uidx_osapuoli_facta_id CASCADE;
CREATE UNIQUE INDEX uidx_osapuoli_facta_id ON jkr.osapuoli
USING btree
(
	facta_id
);
-- ddl-end --

-- object: uidx_osapuoli | type: INDEX --
-- DROP INDEX IF EXISTS jkr.uidx_osapuoli CASCADE;
CREATE UNIQUE INDEX uidx_osapuoli ON jkr.osapuoli
USING btree
(
	sukunimi,
	etunimi,
	katuosoite,
	posti_numero,
	erikoisosoite
);
-- ddl-end --

-- object: jkr_koodistot.rakennuksenkayttotarkoitus | type: TABLE --
-- DROP TABLE IF EXISTS jkr_koodistot.rakennuksenkayttotarkoitus CASCADE;
CREATE TABLE jkr_koodistot.rakennuksenkayttotarkoitus (
	koodi char(3) NOT NULL,
	selite text NOT NULL,
	CONSTRAINT rakennuksenkayttotarkoitus_pk PRIMARY KEY (koodi)
);
-- ddl-end --
ALTER TABLE jkr_koodistot.rakennuksenkayttotarkoitus OWNER TO jkr_admin;
-- ddl-end --

-- object: rakennuksenkayttotarkoitus_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.rakennus DROP CONSTRAINT IF EXISTS rakennuksenkayttotarkoitus_fk CASCADE;
ALTER TABLE jkr.rakennus ADD CONSTRAINT rakennuksenkayttotarkoitus_fk FOREIGN KEY (rakennuksenkayttotarkoitus_koodi)
REFERENCES jkr_koodistot.rakennuksenkayttotarkoitus (koodi) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: jkr_koodistot.rakennuksenolotila | type: TABLE --
-- DROP TABLE IF EXISTS jkr_koodistot.rakennuksenolotila CASCADE;
CREATE TABLE jkr_koodistot.rakennuksenolotila (
	koodi char(2) NOT NULL,
	selite text NOT NULL,
	CONSTRAINT rakennuksenolotila_pk PRIMARY KEY (koodi)
);
-- ddl-end --
ALTER TABLE jkr_koodistot.rakennuksenolotila OWNER TO jkr_admin;
-- ddl-end --

-- object: uidx_rakennuksenolotila_selite | type: INDEX --
-- DROP INDEX IF EXISTS jkr_koodistot.uidx_rakennuksenolotila_selite CASCADE;
CREATE UNIQUE INDEX uidx_rakennuksenolotila_selite ON jkr_koodistot.rakennuksenolotila
USING btree
(
	selite
);
-- ddl-end --

-- object: rakennuksenolotila_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.rakennus DROP CONSTRAINT IF EXISTS rakennuksenolotila_fk CASCADE;
ALTER TABLE jkr.rakennus ADD CONSTRAINT rakennuksenolotila_fk FOREIGN KEY (rakennuksenolotila_koodi)
REFERENCES jkr_koodistot.rakennuksenolotila (koodi) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: jkr_koodistot.osapuolenlaji | type: TABLE --
-- DROP TABLE IF EXISTS jkr_koodistot.osapuolenlaji CASCADE;
CREATE TABLE jkr_koodistot.osapuolenlaji (
	koodi char(2) NOT NULL,
	selite text NOT NULL,
	CONSTRAINT osapuolenlaji_pk PRIMARY KEY (koodi)
);
-- ddl-end --
ALTER TABLE jkr_koodistot.osapuolenlaji OWNER TO jkr_admin;
-- ddl-end --

-- object: uidx_osapuolenlaji_selite | type: INDEX --
-- DROP INDEX IF EXISTS jkr_koodistot.uidx_osapuolenlaji_selite CASCADE;
CREATE UNIQUE INDEX uidx_osapuolenlaji_selite ON jkr_koodistot.osapuolenlaji
USING btree
(
	selite
);
-- ddl-end --

-- object: osapuolenlaji_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.osapuoli DROP CONSTRAINT IF EXISTS osapuolenlaji_fk CASCADE;
ALTER TABLE jkr.osapuoli ADD CONSTRAINT osapuolenlaji_fk FOREIGN KEY (osapuolenlaji_koodi)
REFERENCES jkr_koodistot.osapuolenlaji (koodi) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- -- object: jkr_facta.jh_asiakkuuden_osapuolet | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.jh_asiakkuuden_osapuolet CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.jh_asiakkuuden_osapuolet (
-- 	fid integer NOT NULL,
-- 	kg_kjhasiakkuus double precision,
-- 	c_kiinteistotunnus character varying,
-- 	c_hallyks_kunta character varying,
-- 	c_sijainti character varying,
-- 	c_ryhma character varying,
-- 	c_yksikko character varying,
-- 	c_rooli character varying,
-- 	c_sukunimi character varying,
-- 	c_etunimet character varying,
-- 	c_lahiosoite character varying,
-- 	c_postinro character varying,
-- 	c_puhnro character varying,
-- 	c_sahkopos character varying,
-- 	c_laji character varying,
-- 	c_sotu character varying,
-- 	c_ytunnus character varying,
-- 	c_kotikunta character varying,
-- 	c_onko_kuollut character varying,
-- 	postitmp_fin character varying,
-- 	postitmp_swe character varying,
-- 	c_laskutustunnus character varying,
-- 	c_tyyppi character varying,
-- 	c_asiamies character varying
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'jh_asiakkuuden_osapuolet');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.jh_asiakkuuden_osapuolet OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.koodisto | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.koodisto CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.koodisto (
-- 	fid integer NOT NULL,
-- 	kg_kkoodisto double precision,
-- 	kg_kkoodi double precision,
-- 	c_koodisto character varying,
-- 	c_koodi character varying,
-- 	c_selite character varying,
-- 	c_seliter character varying,
-- 	c_kunta character varying,
-- 	c_selitelyh character varying,
-- 	c_selitelyhr character varying,
-- 	i_numeroselite double precision,
-- 	i_sorttaus double precision,
-- 	c_koodistotyyppi character varying,
-- 	c_nimi character varying,
-- 	c_alkupvm date,
-- 	c_loppupvm date
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'koodisto');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.koodisto OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- -- object: jkr_facta.rakennuksen_osoitteet | type: FOREIGN TABLE --
-- -- DROP FOREIGN TABLE IF EXISTS jkr_facta.rakennuksen_osoitteet CASCADE;
-- CREATE FOREIGN TABLE jkr_facta.rakennuksen_osoitteet (
-- 	fid integer NOT NULL,
-- 	i_pyraknro double precision,
-- 	c_vtj_prt character varying,
-- 	c_vtj_prt_tilanne character varying,
-- 	c_kiinteistotunnus character varying,
-- 	c_kunta character varying,
-- 	c_sijainti character varying,
-- 	c_ryhma character varying,
-- 	c_yksikko character varying,
-- 	kc_raknro character varying,
-- 	c_nimis character varying,
-- 	c_nimir character varying,
-- 	c_osoitenro character varying,
-- 	c_lahiosoite_suomi character varying,
-- 	c_lahiosoite_ruotsi character varying,
-- 	c_postinro character varying,
-- 	i_osnro1 character varying,
-- 	c_oskirj1 character varying,
-- 	i_osnro2 character varying,
-- 	c_oskirj2 character varying,
-- 	postitmp_fin character varying,
-- 	postitmp_swe character varying,
-- 	i_nkoord double precision,
-- 	i_ekoord double precision,
-- 	i_ikoord double precision,
-- 	i_pkoord double precision,
-- 	i_xkoord double precision,
-- 	i_ykoord double precision,
-- 	i_nkoord_tm35fin double precision,
-- 	i_ekoord_tm35fin double precision
-- 
-- )
-- SERVER facta_pg
-- OPTIONS (schema_name 'public',table_name 'rakennuksen_osoitteet');
-- -- ddl-end --
-- ALTER FOREIGN TABLE jkr_facta.rakennuksen_osoitteet OWNER TO jkr_admin;
-- -- ddl-end --
-- 
-- object: idx_rakennuksenkayttotarkoitus_selite | type: INDEX --
-- DROP INDEX IF EXISTS jkr_koodistot.idx_rakennuksenkayttotarkoitus_selite CASCADE;
CREATE INDEX idx_rakennuksenkayttotarkoitus_selite ON jkr_koodistot.rakennuksenkayttotarkoitus
USING btree
(
	selite
);
-- ddl-end --
COMMENT ON INDEX jkr_koodistot.idx_rakennuksenkayttotarkoitus_selite IS E'factassa duplikaattiselitteitä, ei voida käyttää uniikkiindeksiä';
-- ddl-end --

-- object: kunta_fk | type: CONSTRAINT --
-- ALTER TABLE jkr_osoite.posti DROP CONSTRAINT IF EXISTS kunta_fk CASCADE;
ALTER TABLE jkr_osoite.posti ADD CONSTRAINT kunta_fk FOREIGN KEY (kunta_koodi)
REFERENCES jkr_osoite.kunta (koodi) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- -- object: pg_catalog.range_gist_consistent | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_gist_consistent(internal,anyrange,smallint,oid,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.range_gist_consistent (_param1 internal, _param2 anyrange, _param3 smallint, _param4 oid, _param5 internal)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_gist_consistent';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_gist_consistent(internal,anyrange,smallint,oid,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_gist_consistent(internal,anyrange,smallint,oid,internal) IS E'GiST support';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_gist_union | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_gist_union(internal,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.range_gist_union (_param1 internal, _param2 internal)
-- 	RETURNS anyrange
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_gist_union';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_gist_union(internal,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_gist_union(internal,internal) IS E'GiST support';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_gist_penalty | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_gist_penalty(internal,internal,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.range_gist_penalty (_param1 internal, _param2 internal, _param3 internal)
-- 	RETURNS internal
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_gist_penalty';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_gist_penalty(internal,internal,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_gist_penalty(internal,internal,internal) IS E'GiST support';
-- -- ddl-end --
-- 
-- -- object: public.geometry_cp | type: TYPE --
-- -- DROP TYPE IF EXISTS public.geometry_cp CASCADE;
-- CREATE TYPE public.geometry_cp (
-- 	, INTERNALLENGTH = VARIABLE
-- 	, ALIGNMENT = double precision
-- 	, STORAGE = main
-- 	, DELIMITER = ':'
-- 	, CATEGORY = 'U'
-- );
-- -- ddl-end --
-- ALTER TYPE public.geometry_cp OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON TYPE public.geometry_cp IS E'postgis type: The type representing spatial features with planar coordinate systems.';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.int4lt | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.int4lt(integer,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.int4lt (_param1 integer, _param2 integer)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE LEAKPROOF
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'int4lt';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.int4lt(integer,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.int4lt(integer,integer) IS E'implementation of < operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.scalarltsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.scalarltsel(internal,oid,internal,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.scalarltsel (_param1 internal, _param2 oid, _param3 internal, _param4 integer)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'scalarltsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.scalarltsel(internal,oid,internal,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.scalarltsel(internal,oid,internal,integer) IS E'restriction selectivity of < and related operators on scalar datatypes';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.scalarltjoinsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.scalarltjoinsel(internal,oid,internal,smallint,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.scalarltjoinsel (_param1 internal, _param2 oid, _param3 internal, _param4 smallint, _param5 internal)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'scalarltjoinsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.scalarltjoinsel(internal,oid,internal,smallint,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.scalarltjoinsel(internal,oid,internal,smallint,internal) IS E'join selectivity of < and related operators on scalar datatypes';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.< | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.<(integer,integer) CASCADE;
-- CREATE OPERATOR pg_catalog.< (
-- 	PROCEDURE = pg_catalog.int4lt
-- 	, LEFTARG = integer
-- 	, RIGHTARG = integer
-- 	, RESTRICT = pg_catalog.scalarltsel
-- 	, JOIN = pg_catalog.scalarltjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.<(integer,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.<(integer,integer) IS E'less than';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.int4le | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.int4le(integer,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.int4le (_param1 integer, _param2 integer)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE LEAKPROOF
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'int4le';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.int4le(integer,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.int4le(integer,integer) IS E'implementation of <= operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.scalarlesel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.scalarlesel(internal,oid,internal,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.scalarlesel (_param1 internal, _param2 oid, _param3 internal, _param4 integer)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'scalarlesel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.scalarlesel(internal,oid,internal,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.scalarlesel(internal,oid,internal,integer) IS E'restriction selectivity of <= and related operators on scalar datatypes';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.scalarlejoinsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.scalarlejoinsel(internal,oid,internal,smallint,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.scalarlejoinsel (_param1 internal, _param2 oid, _param3 internal, _param4 smallint, _param5 internal)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'scalarlejoinsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.scalarlejoinsel(internal,oid,internal,smallint,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.scalarlejoinsel(internal,oid,internal,smallint,internal) IS E'join selectivity of <= and related operators on scalar datatypes';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.<= | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.<=(integer,integer) CASCADE;
-- CREATE OPERATOR pg_catalog.<= (
-- 	PROCEDURE = pg_catalog.int4le
-- 	, LEFTARG = integer
-- 	, RIGHTARG = integer
-- 	, RESTRICT = pg_catalog.scalarlesel
-- 	, JOIN = pg_catalog.scalarlejoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.<=(integer,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.<=(integer,integer) IS E'less than or equal';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.int4eq | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.int4eq(integer,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.int4eq (_param1 integer, _param2 integer)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE LEAKPROOF
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'int4eq';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.int4eq(integer,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.int4eq(integer,integer) IS E'implementation of = operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.eqsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.eqsel(internal,oid,internal,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.eqsel (_param1 internal, _param2 oid, _param3 internal, _param4 integer)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'eqsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.eqsel(internal,oid,internal,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.eqsel(internal,oid,internal,integer) IS E'restriction selectivity of = and related operators';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.eqjoinsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.eqjoinsel(internal,oid,internal,smallint,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.eqjoinsel (_param1 internal, _param2 oid, _param3 internal, _param4 smallint, _param5 internal)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'eqjoinsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.eqjoinsel(internal,oid,internal,smallint,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.eqjoinsel(internal,oid,internal,smallint,internal) IS E'join selectivity of = and related operators';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.= | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.=(integer,integer) CASCADE;
-- CREATE OPERATOR pg_catalog.= (
-- 	PROCEDURE = pg_catalog.int4eq
-- 	, LEFTARG = integer
-- 	, RIGHTARG = integer
-- 	, RESTRICT = pg_catalog.eqsel
-- 	, JOIN = pg_catalog.eqjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.=(integer,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.=(integer,integer) IS E'equal';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.int4ge | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.int4ge(integer,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.int4ge (_param1 integer, _param2 integer)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE LEAKPROOF
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'int4ge';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.int4ge(integer,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.int4ge(integer,integer) IS E'implementation of >= operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.scalargesel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.scalargesel(internal,oid,internal,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.scalargesel (_param1 internal, _param2 oid, _param3 internal, _param4 integer)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'scalargesel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.scalargesel(internal,oid,internal,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.scalargesel(internal,oid,internal,integer) IS E'restriction selectivity of >= and related operators on scalar datatypes';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.scalargejoinsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.scalargejoinsel(internal,oid,internal,smallint,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.scalargejoinsel (_param1 internal, _param2 oid, _param3 internal, _param4 smallint, _param5 internal)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'scalargejoinsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.scalargejoinsel(internal,oid,internal,smallint,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.scalargejoinsel(internal,oid,internal,smallint,internal) IS E'join selectivity of >= and related operators on scalar datatypes';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.>= | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.>=(integer,integer) CASCADE;
-- CREATE OPERATOR pg_catalog.>= (
-- 	PROCEDURE = pg_catalog.int4ge
-- 	, LEFTARG = integer
-- 	, RIGHTARG = integer
-- 	, RESTRICT = pg_catalog.scalargesel
-- 	, JOIN = pg_catalog.scalargejoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.>=(integer,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.>=(integer,integer) IS E'greater than or equal';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.int4gt | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.int4gt(integer,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.int4gt (_param1 integer, _param2 integer)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE LEAKPROOF
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'int4gt';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.int4gt(integer,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.int4gt(integer,integer) IS E'implementation of > operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.scalargtsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.scalargtsel(internal,oid,internal,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.scalargtsel (_param1 internal, _param2 oid, _param3 internal, _param4 integer)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'scalargtsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.scalargtsel(internal,oid,internal,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.scalargtsel(internal,oid,internal,integer) IS E'restriction selectivity of > and related operators on scalar datatypes';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.scalargtjoinsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.scalargtjoinsel(internal,oid,internal,smallint,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.scalargtjoinsel (_param1 internal, _param2 oid, _param3 internal, _param4 smallint, _param5 internal)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'scalargtjoinsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.scalargtjoinsel(internal,oid,internal,smallint,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.scalargtjoinsel(internal,oid,internal,smallint,internal) IS E'join selectivity of > and related operators on scalar datatypes';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.> | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.>(integer,integer) CASCADE;
-- CREATE OPERATOR pg_catalog.> (
-- 	PROCEDURE = pg_catalog.int4gt
-- 	, LEFTARG = integer
-- 	, RIGHTARG = integer
-- 	, RESTRICT = pg_catalog.scalargtsel
-- 	, JOIN = pg_catalog.scalargtjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.>(integer,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.>(integer,integer) IS E'greater than';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.int4ne | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.int4ne(integer,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.int4ne (_param1 integer, _param2 integer)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE LEAKPROOF
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'int4ne';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.int4ne(integer,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.int4ne(integer,integer) IS E'implementation of <> operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.neqsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.neqsel(internal,oid,internal,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.neqsel (_param1 internal, _param2 oid, _param3 internal, _param4 integer)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'neqsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.neqsel(internal,oid,internal,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.neqsel(internal,oid,internal,integer) IS E'restriction selectivity of <> and related operators';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.neqjoinsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.neqjoinsel(internal,oid,internal,smallint,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.neqjoinsel (_param1 internal, _param2 oid, _param3 internal, _param4 smallint, _param5 internal)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'neqjoinsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.neqjoinsel(internal,oid,internal,smallint,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.neqjoinsel(internal,oid,internal,smallint,internal) IS E'join selectivity of <> and related operators';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.<> | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.<>(integer,integer) CASCADE;
-- CREATE OPERATOR pg_catalog.<> (
-- 	PROCEDURE = pg_catalog.int4ne
-- 	, LEFTARG = integer
-- 	, RIGHTARG = integer
-- 	, COMMUTATOR = OPERATOR(pg_catalog.=)
-- 	, RESTRICT = pg_catalog.neqsel
-- 	, JOIN = pg_catalog.neqjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.<>(integer,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.<>(integer,integer) IS E'not equal';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_gist_picksplit | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_gist_picksplit(internal,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.range_gist_picksplit (_param1 internal, _param2 internal)
-- 	RETURNS internal
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_gist_picksplit';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_gist_picksplit(internal,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_gist_picksplit(internal,internal) IS E'GiST support';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_gist_same | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_gist_same(anyrange,anyrange,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.range_gist_same (_param1 anyrange, _param2 anyrange, _param3 internal)
-- 	RETURNS internal
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_gist_same';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_gist_same(anyrange,anyrange,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_gist_same(anyrange,anyrange,internal) IS E'GiST support';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_before | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_before(anyrange,anyrange) CASCADE;
-- CREATE FUNCTION pg_catalog.range_before (_param1 anyrange, _param2 anyrange)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_before';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_before(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_before(anyrange,anyrange) IS E'implementation of << operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.rangesel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.rangesel(internal,oid,internal,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.rangesel (_param1 internal, _param2 oid, _param3 internal, _param4 integer)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'rangesel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.rangesel(internal,oid,internal,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.rangesel(internal,oid,internal,integer) IS E'restriction selectivity for range operators';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.<< | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.<<(anyrange,anyrange) CASCADE;
-- CREATE OPERATOR pg_catalog.<< (
-- 	PROCEDURE = pg_catalog.range_before
-- 	, LEFTARG = anyrange
-- 	, RIGHTARG = anyrange
-- 	, RESTRICT = pg_catalog.rangesel
-- 	, JOIN = pg_catalog.scalarltjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.<<(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.<<(anyrange,anyrange) IS E'is left of';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_overleft | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_overleft(anyrange,anyrange) CASCADE;
-- CREATE FUNCTION pg_catalog.range_overleft (_param1 anyrange, _param2 anyrange)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_overleft';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_overleft(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_overleft(anyrange,anyrange) IS E'implementation of &< operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.integer_ops | type: OPERATOR FAMILY --
-- -- DROP OPERATOR FAMILY IF EXISTS pg_catalog.integer_ops USING btree CASCADE;
-- CREATE OPERATOR FAMILY pg_catalog.integer_ops USING btree;
-- -- ddl-end --
-- ALTER OPERATOR FAMILY pg_catalog.integer_ops USING btree OWNER TO postgres;
-- -- ddl-end --
-- 
-- -- object: pg_catalog.&< | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.&<(anyrange,anyrange) CASCADE;
-- CREATE OPERATOR pg_catalog.&< (
-- 	PROCEDURE = pg_catalog.range_overleft
-- 	, LEFTARG = anyrange
-- 	, RIGHTARG = anyrange
-- 	, RESTRICT = pg_catalog.rangesel
-- 	, JOIN = pg_catalog.scalarltjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.&<(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.&<(anyrange,anyrange) IS E'overlaps or is left of';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_overlaps | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_overlaps(anyrange,anyrange) CASCADE;
-- CREATE FUNCTION pg_catalog.range_overlaps (_param1 anyrange, _param2 anyrange)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_overlaps';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_overlaps(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_overlaps(anyrange,anyrange) IS E'implementation of && operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.areajoinsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.areajoinsel(internal,oid,internal,smallint,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.areajoinsel (_param1 internal, _param2 oid, _param3 internal, _param4 smallint, _param5 internal)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'areajoinsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.areajoinsel(internal,oid,internal,smallint,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.areajoinsel(internal,oid,internal,smallint,internal) IS E'join selectivity for area-comparison operators';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.&& | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.&&(anyrange,anyrange) CASCADE;
-- CREATE OPERATOR pg_catalog.&& (
-- 	PROCEDURE = pg_catalog.range_overlaps
-- 	, LEFTARG = anyrange
-- 	, RIGHTARG = anyrange
-- 	, RESTRICT = pg_catalog.rangesel
-- 	, JOIN = pg_catalog.areajoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.&&(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.&&(anyrange,anyrange) IS E'overlaps';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_overright | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_overright(anyrange,anyrange) CASCADE;
-- CREATE FUNCTION pg_catalog.range_overright (_param1 anyrange, _param2 anyrange)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_overright';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_overright(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_overright(anyrange,anyrange) IS E'implementation of &> operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.&> | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.&>(anyrange,anyrange) CASCADE;
-- CREATE OPERATOR pg_catalog.&> (
-- 	PROCEDURE = pg_catalog.range_overright
-- 	, LEFTARG = anyrange
-- 	, RIGHTARG = anyrange
-- 	, RESTRICT = pg_catalog.rangesel
-- 	, JOIN = pg_catalog.scalargtjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.&>(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.&>(anyrange,anyrange) IS E'overlaps or is right of';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_after | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_after(anyrange,anyrange) CASCADE;
-- CREATE FUNCTION pg_catalog.range_after (_param1 anyrange, _param2 anyrange)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_after';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_after(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_after(anyrange,anyrange) IS E'implementation of >> operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.>> | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.>>(anyrange,anyrange) CASCADE;
-- CREATE OPERATOR pg_catalog.>> (
-- 	PROCEDURE = pg_catalog.range_after
-- 	, LEFTARG = anyrange
-- 	, RIGHTARG = anyrange
-- 	, RESTRICT = pg_catalog.rangesel
-- 	, JOIN = pg_catalog.scalargtjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.>>(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.>>(anyrange,anyrange) IS E'is right of';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_adjacent | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_adjacent(anyrange,anyrange) CASCADE;
-- CREATE FUNCTION pg_catalog.range_adjacent (_param1 anyrange, _param2 anyrange)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_adjacent';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_adjacent(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_adjacent(anyrange,anyrange) IS E'implementation of -|- operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.matchingsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.matchingsel(internal,oid,internal,integer) CASCADE;
-- CREATE FUNCTION pg_catalog.matchingsel (_param1 internal, _param2 oid, _param3 internal, _param4 integer)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'matchingsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.matchingsel(internal,oid,internal,integer) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.matchingsel(internal,oid,internal,integer) IS E'restriction selectivity for generic matching operators';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.matchingjoinsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.matchingjoinsel(internal,oid,internal,smallint,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.matchingjoinsel (_param1 internal, _param2 oid, _param3 internal, _param4 smallint, _param5 internal)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'matchingjoinsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.matchingjoinsel(internal,oid,internal,smallint,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.matchingjoinsel(internal,oid,internal,smallint,internal) IS E'join selectivity for generic matching operators';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.-|- | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.-|-(anyrange,anyrange) CASCADE;
-- CREATE OPERATOR pg_catalog.-|- (
-- 	PROCEDURE = pg_catalog.range_adjacent
-- 	, LEFTARG = anyrange
-- 	, RIGHTARG = anyrange
-- 	, RESTRICT = pg_catalog.matchingsel
-- 	, JOIN = pg_catalog.matchingjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.-|-(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.-|-(anyrange,anyrange) IS E'is adjacent to';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_contains | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_contains(anyrange,anyrange) CASCADE;
-- CREATE FUNCTION pg_catalog.range_contains (_param1 anyrange, _param2 anyrange)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_contains';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_contains(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_contains(anyrange,anyrange) IS E'implementation of @> operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.contjoinsel | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.contjoinsel(internal,oid,internal,smallint,internal) CASCADE;
-- CREATE FUNCTION pg_catalog.contjoinsel (_param1 internal, _param2 oid, _param3 internal, _param4 smallint, _param5 internal)
-- 	RETURNS double precision
-- 	LANGUAGE internal
-- 	STABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'contjoinsel';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.contjoinsel(internal,oid,internal,smallint,internal) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.contjoinsel(internal,oid,internal,smallint,internal) IS E'join selectivity for containment comparison operators';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.@> | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.@>(anyrange,anyrange) CASCADE;
-- CREATE OPERATOR pg_catalog.@> (
-- 	PROCEDURE = pg_catalog.range_contains
-- 	, LEFTARG = anyrange
-- 	, RIGHTARG = anyrange
-- 	, RESTRICT = pg_catalog.rangesel
-- 	, JOIN = pg_catalog.contjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.@>(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.@>(anyrange,anyrange) IS E'contains';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_contained_by | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_contained_by(anyrange,anyrange) CASCADE;
-- CREATE FUNCTION pg_catalog.range_contained_by (_param1 anyrange, _param2 anyrange)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_contained_by';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_contained_by(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_contained_by(anyrange,anyrange) IS E'implementation of <@ operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.<@ | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.<@(anyrange,anyrange) CASCADE;
-- CREATE OPERATOR pg_catalog.<@ (
-- 	PROCEDURE = pg_catalog.range_contained_by
-- 	, LEFTARG = anyrange
-- 	, RIGHTARG = anyrange
-- 	, RESTRICT = pg_catalog.rangesel
-- 	, JOIN = pg_catalog.contjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.<@(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.<@(anyrange,anyrange) IS E'is contained by';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_contains_elem | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_contains_elem(anyrange,anyelement) CASCADE;
-- CREATE FUNCTION pg_catalog.range_contains_elem (_param1 anyrange, _param2 anyelement)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_contains_elem';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_contains_elem(anyrange,anyelement) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_contains_elem(anyrange,anyelement) IS E'implementation of @> operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.@> | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.@>(anyrange,anyelement) CASCADE;
-- CREATE OPERATOR pg_catalog.@> (
-- 	PROCEDURE = pg_catalog.range_contains_elem
-- 	, LEFTARG = anyrange
-- 	, RIGHTARG = anyelement
-- 	, RESTRICT = pg_catalog.rangesel
-- 	, JOIN = pg_catalog.contjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.@>(anyrange,anyelement) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.@>(anyrange,anyelement) IS E'contains';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_eq | type: FUNCTION --
-- -- DROP FUNCTION IF EXISTS pg_catalog.range_eq(anyrange,anyrange) CASCADE;
-- CREATE FUNCTION pg_catalog.range_eq (_param1 anyrange, _param2 anyrange)
-- 	RETURNS boolean
-- 	LANGUAGE internal
-- 	IMMUTABLE 
-- 	STRICT
-- 	SECURITY INVOKER
-- 	PARALLEL SAFE
-- 	COST 1
-- 	AS 'range_eq';
-- -- ddl-end --
-- ALTER FUNCTION pg_catalog.range_eq(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON FUNCTION pg_catalog.range_eq(anyrange,anyrange) IS E'implementation of = operator';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.= | type: OPERATOR --
-- -- DROP OPERATOR IF EXISTS pg_catalog.=(anyrange,anyrange) CASCADE;
-- CREATE OPERATOR pg_catalog.= (
-- 	PROCEDURE = pg_catalog.range_eq
-- 	, LEFTARG = anyrange
-- 	, RIGHTARG = anyrange
-- 	, RESTRICT = pg_catalog.eqsel
-- 	, JOIN = pg_catalog.eqjoinsel);
-- -- ddl-end --
-- ALTER OPERATOR pg_catalog.=(anyrange,anyrange) OWNER TO postgres;
-- -- ddl-end --
-- COMMENT ON OPERATOR pg_catalog.=(anyrange,anyrange) IS E'equal';
-- -- ddl-end --
-- 
-- -- object: pg_catalog.range_ops | type: OPERATOR CLASS --
-- -- DROP OPERATOR CLASS IF EXISTS pg_catalog.range_ops USING gist CASCADE;
-- CREATE OPERATOR CLASS pg_catalog.range_ops DEFAULT  FOR TYPE anyrange
--  USING gist AS
-- 	FUNCTION	1	pg_catalog.range_gist_consistent(internal,anyrange,smallint,oid,internal),
-- 	FUNCTION	2	pg_catalog.range_gist_union(internal,internal),
-- 	FUNCTION	5	pg_catalog.range_gist_penalty(internal,internal,internal),
-- 	FUNCTION	6	pg_catalog.range_gist_picksplit(internal,internal),
-- 	FUNCTION	7	pg_catalog.range_gist_same(anyrange,anyrange,internal),
-- 	OPERATOR	1	pg_catalog.<<(anyrange,anyrange) FOR SEARCH ,
-- 	OPERATOR	2	pg_catalog.&<(anyrange,anyrange) FOR SEARCH ,
-- 	OPERATOR	3	pg_catalog.&&(anyrange,anyrange) FOR SEARCH ,
-- 	OPERATOR	4	pg_catalog.&>(anyrange,anyrange) FOR SEARCH ,
-- 	OPERATOR	5	pg_catalog.>>(anyrange,anyrange) FOR SEARCH ,
-- 	OPERATOR	6	pg_catalog.-|-(anyrange,anyrange) FOR SEARCH ,
-- 	OPERATOR	7	pg_catalog.@>(anyrange,anyrange) FOR SEARCH ,
-- 	OPERATOR	8	pg_catalog.<@(anyrange,anyrange) FOR SEARCH ,
-- 	OPERATOR	16	pg_catalog.@>(anyrange,anyelement) FOR SEARCH ,
-- 	OPERATOR	18	pg_catalog.=(anyrange,anyrange) FOR SEARCH ;
-- -- ddl-end --
-- ALTER OPERATOR CLASS pg_catalog.range_ops USING gist OWNER TO postgres;
-- -- ddl-end --
-- 
-- object: jkr.sopimus | type: TABLE --
-- DROP TABLE IF EXISTS jkr.sopimus CASCADE;
CREATE TABLE jkr.sopimus (
	id serial NOT NULL,
	alkupvm date,
	loppupvm date,
	urakoitsija_osapuoli_id integer NOT NULL,
	kimppaisanta_kohde_id integer,
	kohde_id integer NOT NULL,
	jatetyyppi_id integer NOT NULL,
	voimassaolo daterange GENERATED ALWAYS AS (daterange(coalesce(alkupvm, '-infinity'), coalesce(loppupvm, 'infinity'), '[]')) STORED,
	CONSTRAINT sopimus_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr.sopimus OWNER TO jkr_admin;
-- ddl-end --

-- object: urakoitsija_osapuoli_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.sopimus DROP CONSTRAINT IF EXISTS urakoitsija_osapuoli_fk CASCADE;
ALTER TABLE jkr.sopimus ADD CONSTRAINT urakoitsija_osapuoli_fk FOREIGN KEY (urakoitsija_osapuoli_id)
REFERENCES jkr.osapuoli (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: kimppaisanta_kohde_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.sopimus DROP CONSTRAINT IF EXISTS kimppaisanta_kohde_fk CASCADE;
ALTER TABLE jkr.sopimus ADD CONSTRAINT kimppaisanta_kohde_fk FOREIGN KEY (kimppaisanta_kohde_id)
REFERENCES jkr.kohde (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: sopimus_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.keraysvaline DROP CONSTRAINT IF EXISTS sopimus_fk CASCADE;
ALTER TABLE jkr.keraysvaline ADD CONSTRAINT sopimus_fk FOREIGN KEY (sopimus_id)
REFERENCES jkr.sopimus (id) MATCH FULL
ON DELETE RESTRICT ON UPDATE CASCADE;
-- ddl-end --

-- object: sopimus_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.tyhjennysvali DROP CONSTRAINT IF EXISTS sopimus_fk CASCADE;
ALTER TABLE jkr.tyhjennysvali ADD CONSTRAINT sopimus_fk FOREIGN KEY (sopimus_id)
REFERENCES jkr.sopimus (id) MATCH FULL
ON DELETE RESTRICT ON UPDATE CASCADE;
-- ddl-end --

-- object: sopimus_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.keskeytys DROP CONSTRAINT IF EXISTS sopimus_fk CASCADE;
ALTER TABLE jkr.keskeytys ADD CONSTRAINT sopimus_fk FOREIGN KEY (sopimus_id)
REFERENCES jkr.sopimus (id) MATCH FULL
ON DELETE RESTRICT ON UPDATE CASCADE;
-- ddl-end --

-- object: kohde_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.sopimus DROP CONSTRAINT IF EXISTS kohde_fk CASCADE;
ALTER TABLE jkr.sopimus ADD CONSTRAINT kohde_fk FOREIGN KEY (kohde_id)
REFERENCES jkr.kohde (id) MATCH FULL
ON DELETE RESTRICT ON UPDATE CASCADE;
-- ddl-end --

-- object: jatetyyppi_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.sopimus DROP CONSTRAINT IF EXISTS jatetyyppi_fk CASCADE;
ALTER TABLE jkr.sopimus ADD CONSTRAINT jatetyyppi_fk FOREIGN KEY (jatetyyppi_id)
REFERENCES jkr_koodistot.jatetyyppi (id) MATCH FULL
ON DELETE RESTRICT ON UPDATE CASCADE;
-- ddl-end --

-- -- object: btree_gist | type: EXTENSION --
-- -- DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- CREATE EXTENSION btree_gist
-- ;
-- -- ddl-end --
-- 
-- object: jatetyyppi_selite_uidx | type: INDEX --
-- DROP INDEX IF EXISTS jkr_koodistot.jatetyyppi_selite_uidx CASCADE;
CREATE UNIQUE INDEX jatetyyppi_selite_uidx ON jkr_koodistot.jatetyyppi
USING btree
(
	selite
);
-- ddl-end --

-- object: jkr.ulkoinen_kohdetunnus | type: TABLE --
-- DROP TABLE IF EXISTS jkr.ulkoinen_kohdetunnus CASCADE;
CREATE TABLE jkr.ulkoinen_kohdetunnus (
	id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	tiedontuottaja_tunnus char(3) NOT NULL,
	ulkoinen_id text NOT NULL,
	kohde_id integer NOT NULL,
	CONSTRAINT ulkoinen_kohdetunnus_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr.ulkoinen_kohdetunnus OWNER TO jkr_admin;
-- ddl-end --

-- object: kohde_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.ulkoinen_kohdetunnus DROP CONSTRAINT IF EXISTS kohde_fk CASCADE;
ALTER TABLE jkr.ulkoinen_kohdetunnus ADD CONSTRAINT kohde_fk FOREIGN KEY (kohde_id)
REFERENCES jkr.kohde (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: jkr_koodistot.osapuolenrooli | type: TABLE --
-- DROP TABLE IF EXISTS jkr_koodistot.osapuolenrooli CASCADE;
CREATE TABLE jkr_koodistot.osapuolenrooli (
	id smallint NOT NULL GENERATED BY DEFAULT AS IDENTITY ,
	selite text,
	CONSTRAINT osapuolenrooli_pk PRIMARY KEY (id)
);
-- ddl-end --
ALTER TABLE jkr_koodistot.osapuolenrooli OWNER TO jkr_admin;
-- ddl-end --

-- object: jkr.kohteen_osapuolet | type: TABLE --
-- DROP TABLE IF EXISTS jkr.kohteen_osapuolet CASCADE;
CREATE TABLE jkr.kohteen_osapuolet (
	kohde_id integer NOT NULL,
	osapuoli_id integer NOT NULL,
	osapuolenrooli_id smallint,
	CONSTRAINT kohteen_osapuolet_pk PRIMARY KEY (kohde_id,osapuoli_id)
);
-- ddl-end --
ALTER TABLE jkr.kohteen_osapuolet OWNER TO jkr_admin;
-- ddl-end --

-- object: kohde_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.kohteen_osapuolet DROP CONSTRAINT IF EXISTS kohde_fk CASCADE;
ALTER TABLE jkr.kohteen_osapuolet ADD CONSTRAINT kohde_fk FOREIGN KEY (kohde_id)
REFERENCES jkr.kohde (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: osapuoli_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.kohteen_osapuolet DROP CONSTRAINT IF EXISTS osapuoli_fk CASCADE;
ALTER TABLE jkr.kohteen_osapuolet ADD CONSTRAINT osapuoli_fk FOREIGN KEY (osapuoli_id)
REFERENCES jkr.osapuoli (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: osapuolenrooli_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.kohteen_osapuolet DROP CONSTRAINT IF EXISTS osapuolenrooli_fk CASCADE;
ALTER TABLE jkr.kohteen_osapuolet ADD CONSTRAINT osapuolenrooli_fk FOREIGN KEY (osapuolenrooli_id)
REFERENCES jkr_koodistot.osapuolenrooli (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: exc_overlapping | type: CONSTRAINT --
-- ALTER TABLE jkr.sopimus DROP CONSTRAINT IF EXISTS exc_overlapping CASCADE;
ALTER TABLE jkr.sopimus ADD CONSTRAINT exc_overlapping EXCLUDE 
	USING gist(
	  kohde_id WITH pg_catalog.=,
	  jatetyyppi_id WITH pg_catalog.=,
	  voimassaolo WITH pg_catalog.&&
	);
-- ddl-end --

-- object: jkr.kohteen_rakennukset | type: TABLE --
-- DROP TABLE IF EXISTS jkr.kohteen_rakennukset CASCADE;
CREATE TABLE jkr.kohteen_rakennukset (
	rakennus_id integer NOT NULL,
	kohde_id integer NOT NULL,
	CONSTRAINT kohteen_rakennukset_pk PRIMARY KEY (rakennus_id,kohde_id)
);
-- ddl-end --
ALTER TABLE jkr.kohteen_rakennukset OWNER TO jkr_admin;
-- ddl-end --

-- object: rakennus_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.kohteen_rakennukset DROP CONSTRAINT IF EXISTS rakennus_fk CASCADE;
ALTER TABLE jkr.kohteen_rakennukset ADD CONSTRAINT rakennus_fk FOREIGN KEY (rakennus_id)
REFERENCES jkr.rakennus (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: kohde_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.kohteen_rakennukset DROP CONSTRAINT IF EXISTS kohde_fk CASCADE;
ALTER TABLE jkr.kohteen_rakennukset ADD CONSTRAINT kohde_fk FOREIGN KEY (kohde_id)
REFERENCES jkr.kohde (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: trg_after_kohde_rakennus_change | type: TRIGGER --
-- DROP TRIGGER IF EXISTS trg_after_kohde_rakennus_change ON jkr.kohteen_rakennukset CASCADE;
CREATE TRIGGER trg_after_kohde_rakennus_change
	AFTER INSERT OR DELETE OR UPDATE
	ON jkr.kohteen_rakennukset
	FOR EACH ROW
	EXECUTE PROCEDURE jkr.update_kohde_geom();
-- ddl-end --

-- object: trg_after_truncate | type: TRIGGER --
-- DROP TRIGGER IF EXISTS trg_after_truncate ON jkr.kohteen_rakennukset CASCADE;
CREATE TRIGGER trg_after_truncate
	AFTER TRUNCATE 
	ON jkr.kohteen_rakennukset
	FOR EACH STATEMENT
	EXECUTE PROCEDURE jkr.update_kohde_geom();
-- ddl-end --

-- object: idx_kohteen_rakennukset_kohde_id | type: INDEX --
-- DROP INDEX IF EXISTS jkr.idx_kohteen_rakennukset_kohde_id CASCADE;
CREATE INDEX idx_kohteen_rakennukset_kohde_id ON jkr.kohteen_rakennukset
USING btree
(
	kohde_id
);
-- ddl-end --

-- object: kohde_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.kuljetus DROP CONSTRAINT IF EXISTS kohde_fk CASCADE;
ALTER TABLE jkr.kuljetus ADD CONSTRAINT kohde_fk FOREIGN KEY (kohde_id)
REFERENCES jkr.kohde (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: jatetyyppi_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.kuljetus DROP CONSTRAINT IF EXISTS jatetyyppi_fk CASCADE;
ALTER TABLE jkr.kuljetus ADD CONSTRAINT jatetyyppi_fk FOREIGN KEY (jatetyyppi_id)
REFERENCES jkr_koodistot.jatetyyppi (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: urakoitsija_osapuoli_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.kuljetus DROP CONSTRAINT IF EXISTS urakoitsija_osapuoli_fk CASCADE;
ALTER TABLE jkr.kuljetus ADD CONSTRAINT urakoitsija_osapuoli_fk FOREIGN KEY (urakoitsija_osapuoli_id)
REFERENCES jkr.osapuoli (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: tiedontuottaja_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.ulkoinen_kohdetunnus DROP CONSTRAINT IF EXISTS tiedontuottaja_fk CASCADE;
ALTER TABLE jkr.ulkoinen_kohdetunnus ADD CONSTRAINT tiedontuottaja_fk FOREIGN KEY (tiedontuottaja_tunnus)
REFERENCES jkr_koodistot.tiedontuottaja (tunnus) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: uidx_ulkoinen_kohdetunnus | type: INDEX --
-- DROP INDEX IF EXISTS jkr.uidx_ulkoinen_kohdetunnus CASCADE;
CREATE UNIQUE INDEX uidx_ulkoinen_kohdetunnus ON jkr.ulkoinen_kohdetunnus
USING btree
(
	tiedontuottaja_tunnus,
	ulkoinen_id
);
-- ddl-end --

-- object: kohde_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.facta_asia DROP CONSTRAINT IF EXISTS kohde_fk CASCADE;
ALTER TABLE jkr.facta_asia ADD CONSTRAINT kohde_fk FOREIGN KEY (kohde_id)
REFERENCES jkr.kohde (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: idx_sopimus_kohde_id | type: INDEX --
-- DROP INDEX IF EXISTS jkr.idx_sopimus_kohde_id CASCADE;
CREATE INDEX idx_sopimus_kohde_id ON jkr.sopimus
USING btree
(
	kohde_id
);
-- ddl-end --

-- object: idx_ulkoinen_kohdetunnus_kohde_id | type: INDEX --
-- DROP INDEX IF EXISTS jkr.idx_ulkoinen_kohdetunnus_kohde_id CASCADE;
CREATE INDEX idx_ulkoinen_kohdetunnus_kohde_id ON jkr.ulkoinen_kohdetunnus
USING btree
(
	kohde_id
);
-- ddl-end --

-- object: idx_keraysvaline_sopimus_id | type: INDEX --
-- DROP INDEX IF EXISTS jkr.idx_keraysvaline_sopimus_id CASCADE;
CREATE INDEX idx_keraysvaline_sopimus_id ON jkr.keraysvaline
USING btree
(
	sopimus_id
);
-- ddl-end --

-- object: idx_keskeytys_sopimus_id | type: INDEX --
-- DROP INDEX IF EXISTS jkr.idx_keskeytys_sopimus_id CASCADE;
CREATE INDEX idx_keskeytys_sopimus_id ON jkr.keskeytys
USING btree
(
	sopimus_id
);
-- ddl-end --

-- object: idx_tyhjennysvali_sopimus_id | type: INDEX --
-- DROP INDEX IF EXISTS jkr.idx_tyhjennysvali_sopimus_id CASCADE;
CREATE INDEX idx_tyhjennysvali_sopimus_id ON jkr.tyhjennysvali
USING btree
(
	sopimus_id
);
-- ddl-end --

-- object: idx_kuljetus_kohde_id | type: INDEX --
-- DROP INDEX IF EXISTS jkr.idx_kuljetus_kohde_id CASCADE;
CREATE INDEX idx_kuljetus_kohde_id ON jkr.kuljetus
USING btree
(
	kohde_id
);
-- ddl-end --

-- object: idx_facta_asia_kohde_id | type: INDEX --
-- DROP INDEX IF EXISTS jkr.idx_facta_asia_kohde_id CASCADE;
CREATE INDEX idx_facta_asia_kohde_id ON jkr.facta_asia
USING btree
(
	kohde_id
);
-- ddl-end --

-- object: idx_osoite_rakennus_id | type: INDEX --
-- DROP INDEX IF EXISTS jkr.idx_osoite_rakennus_id CASCADE;
CREATE INDEX idx_osoite_rakennus_id ON jkr.osoite
USING btree
(
	rakennus_id
);
-- ddl-end --

-- object: jkr.rakennuksen_omistajat | type: TABLE --
-- DROP TABLE IF EXISTS jkr.rakennuksen_omistajat CASCADE;
CREATE TABLE jkr.rakennuksen_omistajat (
	id_rakennus integer NOT NULL,
	id_osapuoli integer NOT NULL,
	CONSTRAINT rakennuksen_omistajat_pk PRIMARY KEY (id_rakennus,id_osapuoli)
);
-- ddl-end --
ALTER TABLE jkr.rakennuksen_omistajat OWNER TO jkr_admin;
-- ddl-end --

-- object: rakennus_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.rakennuksen_omistajat DROP CONSTRAINT IF EXISTS rakennus_fk CASCADE;
ALTER TABLE jkr.rakennuksen_omistajat ADD CONSTRAINT rakennus_fk FOREIGN KEY (id_rakennus)
REFERENCES jkr.rakennus (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: osapuoli_fk | type: CONSTRAINT --
-- ALTER TABLE jkr.rakennuksen_omistajat DROP CONSTRAINT IF EXISTS osapuoli_fk CASCADE;
ALTER TABLE jkr.rakennuksen_omistajat ADD CONSTRAINT osapuoli_fk FOREIGN KEY (id_osapuoli)
REFERENCES jkr.osapuoli (id) MATCH FULL
ON DELETE CASCADE ON UPDATE CASCADE;
-- ddl-end --

-- object: idx_rakennuksen_omistajat_osapuoli_id | type: INDEX --
-- DROP INDEX IF EXISTS jkr.idx_rakennuksen_omistajat_osapuoli_id CASCADE;
CREATE INDEX idx_rakennuksen_omistajat_osapuoli_id ON jkr.rakennuksen_omistajat
USING btree
(
	id_osapuoli
);
-- ddl-end --

-- object: idx_osoite_katu_id | type: INDEX --
-- DROP INDEX IF EXISTS jkr.idx_osoite_katu_id CASCADE;
CREATE INDEX idx_osoite_katu_id ON jkr.osoite
USING btree
(
	katu_id
);
-- ddl-end --

-- object: idx_osoite_postinumero | type: INDEX --
-- DROP INDEX IF EXISTS jkr.idx_osoite_postinumero CASCADE;
CREATE INDEX idx_osoite_postinumero ON jkr.osoite
USING btree
(
	posti_numero
);
-- ddl-end --

-- object: idx_katu_kunta_koodi | type: INDEX --
-- DROP INDEX IF EXISTS jkr_osoite.idx_katu_kunta_koodi CASCADE;
CREATE INDEX idx_katu_kunta_koodi ON jkr_osoite.katu
USING btree
(
	kunta_koodi
);
-- ddl-end --

-- object: idx_posti_kunta_koodi | type: INDEX --
-- DROP INDEX IF EXISTS jkr_osoite.idx_posti_kunta_koodi CASCADE;
CREATE INDEX idx_posti_kunta_koodi ON jkr_osoite.posti
USING btree
(
	kunta_koodi
);
-- ddl-end --


